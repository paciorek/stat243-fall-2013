#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[unicode=true]{hyperref}
\usepackage{/accounts/gen/vis/paciorek/latex/paciorek-asa,times,graphics}
\input{/accounts/gen/vis/paciorek/latex/paciorekMacros}
%\renewcommand{\baselinestretch}{1.5}
\hypersetup{unicode=true, pdfusetitle,bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true,}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setup, include=FALSE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

## I use = but I can replace it with <-; set code/output width to be 68
\end_layout

\begin_layout Plain Layout

options(replace.assign=TRUE, width=68)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Title
R Programming
\end_layout

\begin_layout Standard
References: 
\end_layout

\begin_layout Itemize
Adler
\end_layout

\begin_layout Itemize
Chambers 
\end_layout

\begin_layout Itemize
Murrell, Introduction to Data Technologies.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "R intro manual"
target "http://cran.r-project.org/doc/manuals/R-intro.html"

\end_inset

 (R-intro) and 
\begin_inset CommandInset href
LatexCommand href
name "R language manual"
target "http://cran.r-project.org/doc/manuals/R-lang.html"

\end_inset

 (R-lang), both on CRAN.
\end_layout

\begin_layout Itemize
Venables and Ripley, Modern Applied Statistics with S
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://www.burns-stat.com/pages/Tutor/R_inferno.pdf for discussion of efficiency
 in R
\end_layout

\begin_layout Plain Layout
http://faculty.washington.edu/tlumley/Rcourse/R-fundamentals.pdf 
\end_layout

\begin_layout Plain Layout
http://bioconductor.org/help/course-materials/2010/BioC2010/EfficientRProgramming.
pdf
\end_layout

\begin_layout Plain Layout
http://bioconductor.org/help/course-materials/2010/BioC2010/EfficientRProgramming
Exercises.pdf 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Enumerate
Data structures, types (DTL)
\end_layout

\begin_layout Enumerate
packages, .Rprofile stuff
\end_layout

\begin_layout Enumerate
Flow control (use 'identical' not ==), & vs &&
\end_layout

\begin_layout Enumerate
Functions and scope and closures (DTL),
\end_layout

\begin_layout Enumerate
pass by ref and value, 
\end_layout

\begin_layout Enumerate
environments (a bit on pointers in C), search path, search(), pos in ls()
\end_layout

\begin_layout Enumerate
operators - [operators are just functions: myMat = sapply(myList, "[[",
 1) 
\end_layout

\begin_layout Enumerate
OOP (RPeng notes), classes
\end_layout

\begin_layout Enumerate
Array/matrices/storage/pointers:
\end_layout

\begin_deeper
\begin_layout Enumerate
Phil's doc
\end_layout

\begin_layout Enumerate
SEXP and persistent pointers?
\end_layout

\begin_layout Enumerate
subscripting - characters, logical subscripts -see Phil p.
 8 of R doc
\end_layout

\end_deeper
\begin_layout Enumerate
efficiency: pre-allocation, rowMeans, apply vs.
 matrix operations, picking out elements with vector/matrix identity information
, sparse calculations, direct product vs.
 matrix mult say for diagonal elements [use examples from Mariel's work]
 [see DTL rw1.r]
\end_layout

\begin_layout Enumerate
various 'applys', do.call(), plyr package, by(), split(); to get 2nd element
 out of all list items: sapply(lis,'[', 2), unlist()
\end_layout

\begin_layout Enumerate
operating on the language, parsing, expressions
\end_layout

\begin_layout Enumerate
quotes
\end_layout

\begin_layout Enumerate
formulas
\end_layout

\end_inset


\end_layout

\begin_layout Section
Efficiency
\end_layout

\begin_layout Standard
In general, make use of R's built-in functions, as these tend to be implemented
 internally (i.e., via compiled code in C or Fortran).
 In particular, if R is linked to optimized BLAS and Lapack code (e.g.
 Intel's 
\emph on
MKL
\emph default
, 
\emph on
OpenBLAS
\emph default
 [on the SCF Linux servers], AMD's 
\emph on
ACML
\emph default
 [on the SCF Linux cluster, 
\emph on
vecLib
\emph default
 for Macs [on the SCF Macs]), you should have good performance (potentially
 comparable to Matlab and to coding in C).
 Often you can figure out a trick to take your problem and transform it
 to make use of the built-in functions.
\end_layout

\begin_layout Standard
Note that I run a lot of MCMCs so I pay attention to making sure my calculations
 are fast as they are done repeatedly.
 Similarly, one would want to pay attention to speed when doing large simulation
s and bootstrapping, and in some cases for optimization.
 And if you're distributing code, it's good to have it be efficient.
 But in other contexts, it may not be worth your time.
 Also, it's good practice to code it transparently first to reduce bugs
 and then to use tricks to speed it up and make sure the fast version works
 correctly.
 
\end_layout

\begin_layout Standard
Results can vary with with your system setup and version of R, so the best
 thing to do is figure out where the bottlenecks are in your code (e.g., with
 
\emph on
Rprof()
\emph default
 or just some basic use of 
\emph on
system.time()
\emph default
 and 
\emph on
benchmark()
\emph default
), and then play around with alternative specifications.
 And as you gain more experience, you'll get some intuition for what approaches
 might improve speed, but even with experience I find myself often surprised
 by what matters and what doesn't.
 It's often worth trying out a bunch of different ideas; 
\emph on
system.time()
\emph default
 and 
\emph on
benchmark()
\emph default
 are your workhorse tools in this context.
\end_layout

\begin_layout Standard
First, let's see some tools for assessing the speed of your code.
\end_layout

\begin_layout Subsection
Tools for assessing efficiency
\end_layout

\begin_layout Subsubsection
Benchmarking
\end_layout

\begin_layout Standard

\emph on
system.time()
\emph default
 is very handy for comparing the speed of different implementations.
 
\end_layout

\begin_layout Chunk
<<chunk001>>=
\end_layout

\begin_layout Chunk
n <- 1000
\end_layout

\begin_layout Chunk
x <- matrix(rnorm(n^2), n)
\end_layout

\begin_layout Chunk
system.time({mns <- rep(NA, n); for(i in 1:n) mns[i] <- mean(x[i , ])})
\end_layout

\begin_layout Chunk
system.time(rowMeans(x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The 
\emph on
rbenchmark
\emph default
 package provides a nice wrapper function, 
\emph on
benchmark()
\emph default
, that automates speed assessments.
 
\end_layout

\begin_layout Chunk
<<chunk002>>=
\end_layout

\begin_layout Chunk
library(rbenchmark)
\end_layout

\begin_layout Chunk
# speed of one calculation
\end_layout

\begin_layout Chunk
n <- 1000
\end_layout

\begin_layout Chunk
x <- matrix(rnorm(n^2), n)
\end_layout

\begin_layout Chunk
benchmark(crossprod(x), replications = 10, columns=c('test', 'elapsed',
 'replications'))
\end_layout

\begin_layout Chunk
# comparing different approaches to a task
\end_layout

\begin_layout Chunk
benchmark(
\end_layout

\begin_layout Chunk
{mns <- rep(NA, n); for(i in 1:n) mns[i] <- mean(x[i , ])},
\end_layout

\begin_layout Chunk
rowMeans(x), 
\end_layout

\begin_layout Chunk
replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsubsection
Profiling
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Enumerate
Rprof (see rw1.r on DTL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
Rprof()
\emph default
 function will show you how much time is spent in different functions, which
 can help you pinpoint bottlenecks in your code.
 
\end_layout

\begin_layout Standard
Here's a function that works with a correlation matrix such as one might
 have for time series data.
\end_layout

\begin_layout Chunk
<<chunk003a, eval=FALSE>>=
\end_layout

\begin_layout Chunk
makeTS <- function(param, len){
\end_layout

\begin_layout Chunk
	times <- seq(0, 1, length = len)
\end_layout

\begin_layout Chunk
	dd <- rdist(times)
\end_layout

\begin_layout Chunk
	C <- exp(-dd/param)
\end_layout

\begin_layout Chunk
	U <- chol(C)
\end_layout

\begin_layout Chunk
	white <- rnorm(len)
\end_layout

\begin_layout Chunk
	return(crossprod(U, white))
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk
<<chunk003, eval=FALSE>>=
\end_layout

\begin_layout Chunk
library(fields)
\end_layout

\begin_layout Chunk
Rprof("makeTS.prof")
\end_layout

\begin_layout Chunk
out <- makeTS(0.1, 1000)
\end_layout

\begin_layout Chunk
Rprof(NULL)
\end_layout

\begin_layout Chunk
summaryRprof("makeTS.prof")
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Here's the result for the 
\emph on
makeTS()
\emph default
 function from the demo code file:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

$by.self   self.time self.pct total.time total.pct 
\end_layout

\begin_layout Plain Layout

".Call"         0.38    48.72       0.38     48.72 
\end_layout

\begin_layout Plain Layout

".Fortran"      0.22    28.21       0.22     28.21 
\end_layout

\begin_layout Plain Layout

"matrix"        0.08    10.26       0.30     38.46 
\end_layout

\begin_layout Plain Layout

"exp"           0.08    10.26       0.08     10.26 
\end_layout

\begin_layout Plain Layout

"/"             0.02     2.56       0.02      2.56
\end_layout

\begin_layout Plain Layout

$by.total         total.time total.pct self.time self.pct 
\end_layout

\begin_layout Plain Layout

"makeTS"                0.78    100.00      0.00     0.00 
\end_layout

\begin_layout Plain Layout

".Call"                 0.38     48.72      0.38    48.72 
\end_layout

\begin_layout Plain Layout

"chol.default"          0.38     48.72      0.00     0.00 
\end_layout

\begin_layout Plain Layout

"chol"                  0.38     48.72      0.00     0.00 
\end_layout

\begin_layout Plain Layout

"standardGeneric"       0.38     48.72      0.00     0.00 
\end_layout

\begin_layout Plain Layout

"matrix"                0.30     38.46      0.08    10.26 
\end_layout

\begin_layout Plain Layout

"rdist"                 0.30     38.46      0.00     0.00 
\end_layout

\begin_layout Plain Layout

".Fortran"              0.22     28.21      0.22    28.21 
\end_layout

\begin_layout Plain Layout

"exp"                   0.08     10.26      0.08    10.26 
\end_layout

\begin_layout Plain Layout

"/"                     0.02      2.56      0.02     2.56
\end_layout

\begin_layout Plain Layout

$sample.interval [1] 0.02
\end_layout

\begin_layout Plain Layout

$sampling.time [1] 0.78
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
Rprof()
\emph default
 tells how much time was spent in each function alone (the 
\emph on

\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset


\emph default
 columns) and aggregating the time spent in a function and all of the functions
 that it calls (the 
\emph on

\begin_inset Quotes eld
\end_inset

total
\begin_inset Quotes erd
\end_inset


\emph default
 columns).
 Usually the former is going to be more useful, but in some cases we need
 to decipher what is going on based on the latter.
\end_layout

\begin_layout Standard
Let's figure out what is going on here.
 The self time tells us that 
\emph on
.Call
\emph default
 (a call to C code), 
\emph on
.Fortran
\emph default
 (a call to Fortran code) and 
\emph on
matrix()
\emph default
 take up most of the time.
 Looking at the total time and seeing in 
\emph on
chol.default()
\emph default
 that 
\emph on
.Call
\emph default
 is used (you would have to go in and look at the 
\emph on
La_chol()
\emph default
 function to figure this out) and in 
\emph on
rdist()
\emph default
 that 
\emph on
.Fortran()
\emph default
 and 
\emph on
matrix()
\emph default
 are used we can infer that about 49% of the time is being spent in the
 Cholesky and 38% in the 
\emph on
rdist()
\emph default
 calculation, with 10% in 
\emph on
exp()
\emph default
.
 As we increase the number of time points, the time taken up by the Cholesky
 would increase since that calculation is order of 
\begin_inset Formula $n^{3}$
\end_inset

 while the others are order 
\begin_inset Formula $n^{2}$
\end_inset

 (more in the linear algebra unit).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As another example you can try out 
\emph on
Rprof()
\emph default
 on different implementations of the random walk from PS3.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Apparently there is a memory profiler in R, 
\emph on
Rprofmem()
\emph default
, but it needs to be enabled when R is compiled (i.e., installed on the machine),
 because it slows R down even when not used.
 So I've never gotten to the point of playing around with it.
\end_layout

\begin_layout Standard

\series bold
Warning
\series default
: 
\emph on
Rprof()
\emph default
 conflicts with threaded linear algebra, so you will need to set OMP_NUM_THREADS
 to 1 to disable threaded linear algebra if you profile code that involves
 linear algebra.
 More about this in the unit on parallel processing.
\end_layout

\begin_layout Subsection
Strategies for improving efficiency
\end_layout

\begin_layout Subsubsection
Fast initialization
\end_layout

\begin_layout Standard
It is very inefficient to iteratively add elements to a vector, matrix,
 data frame, array or list (e.g., iteratively using 
\emph on
c()
\emph default
, 
\emph on
cbind()
\emph default
, 
\emph on
rbind()
\emph default
, etc.).
 Instead, create the full object in advance (this is equivalent to variable
 initialization in compiled languages) and then fill in the appropriate
 elements.
 The reason is that when R appends to an existing object, it creates a new
 copy and as the object gets big, this gets slow when one does it a lot
 of times.
 Here's an illustrative example, but of course we would not fill a vector
 like this because we would in practice use vectorized calculations.
\end_layout

\begin_layout Chunk
<<chunk1>>=
\end_layout

\begin_layout Chunk
n <- 1000
\end_layout

\begin_layout Chunk
x <- 1; 
\end_layout

\begin_layout Chunk
benchmark( for(i in 2:n) x <- c(x, i), 
\end_layout

\begin_layout Chunk
{x <- rep(as.numeric(NA), n); for(i in 1:n) x[i] <- i},
\end_layout

\begin_layout Chunk
replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
It's not necessary to use 
\emph on
as.numeric()
\emph default
 above though it saves a bit of time.
 
\series bold
Challenge
\series default
: figure out why I have 
\family typewriter
as.numeric(NA)
\family default
 and not just 
\family typewriter
NA
\family default
.
\end_layout

\begin_layout Standard
We can actually speed up the initialization (though in most practical circumstan
ces, the second approach here would be overkill):
\end_layout

\begin_layout Chunk
<<chunk2>>=
\end_layout

\begin_layout Chunk
n <- 1000000
\end_layout

\begin_layout Chunk
benchmark(x <- rep(as.numeric(NA), n),
\end_layout

\begin_layout Chunk
{x <- as.numeric(NA); length(x) <- n},
\end_layout

\begin_layout Chunk
replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
For matrices, start with the right length vector and then change the dimensions
\end_layout

\begin_layout Chunk
<<chunk3>>=
\end_layout

\begin_layout Chunk
nr <- nc <- 2000
\end_layout

\begin_layout Chunk
benchmark(x <- matrix(as.numeric(NA), nr, nc),
\end_layout

\begin_layout Chunk
{x <- as.numeric(NA); length(x) <- nr * nc; dim(x) <- c(nr, nc)},
\end_layout

\begin_layout Chunk
replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
For lists, we can do this
\end_layout

\begin_layout Chunk
<<chunk3a>>=
\end_layout

\begin_layout Chunk
myList <- vector("list", length = n)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Subsubsection
Vectorized calculations
\end_layout

\begin_layout Standard
One key way to write efficient R code is to take advantage of R's vectorized
 operations.
\end_layout

\begin_layout Chunk
<<chunk4>>=
\end_layout

\begin_layout Chunk
n <- 1e6
\end_layout

\begin_layout Chunk
x <- rnorm(n)
\end_layout

\begin_layout Chunk
system.time(x2 <- x^2)
\end_layout

\begin_layout Chunk
x2 <- as.numeric(NA)
\end_layout

\begin_layout Chunk
system.time({length(x2) <- n; for(i in 1:n){ x2[i] <- x[i]^2}}) # how many
 orders of magnitude slower?
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
So what is different in how R handles the calculations above that explains
 the disparity? The vectorized calculation is being done natively in C in
 a for loop.
 The for loop above involves executing the for loop in R with repeated calls
 to C code at each iteration.
 You can usually get a sense for how quickly an R call will pass things
 along to C by looking at the body of the relevant function(s) being called
 and looking for 
\emph on
.Primitive
\emph default
, 
\emph on
.Internal
\emph default
, 
\emph on
.C,
\emph default
 
\emph on
.Call
\emph default
, or 
\emph on
.Fortran
\emph default
.
 Let's take a look at the code for `
\emph on
+
\emph default
`, 
\emph on
mean.default()
\emph default
, and 
\emph on
chol.default()
\emph default
.
 
\end_layout

\begin_layout Standard
Many R functions allow you to pass in vectors, and operate on those vectors
 in vectorized fashion.
 So before writing a for loop, look at the help information on the relevant
 function(s) to see if they operate in a vectorized fashion.
\end_layout

\begin_layout Chunk
<<chunk5>>=
\end_layout

\begin_layout Chunk
line <- c("Four score and 7 years ago, this nation")
\end_layout

\begin_layout Chunk
startIndices = seq(1, by = 3, length = nchar(line)/3)
\end_layout

\begin_layout Chunk
substring(line, startIndices, startIndices + 1)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: Consider the chi-squared statistic involved in a test of independence
 in a contingency table:
\begin_inset Formula 
\[
\chi^{2}=\sum_{i}\sum_{j}\frac{(y_{ij}-e_{ij})^{2}}{e_{ij}},\,\,\,\, e_{ij}=\frac{y_{i\cdot}y_{\cdot j}}{y_{\cdot\cdot}}
\]

\end_inset

where 
\begin_inset Formula $f_{i\cdot}=\sum_{j}f_{ij}$
\end_inset

.
 Write this in a vectorized way without any loops.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[chisquare.q]
\end_layout

\end_inset

 Note that 'vectorized' calculations also work with matrices and arrays.
\end_layout

\begin_layout Standard
Vectorized operations can also be faster than built-in functions, and clever
 vectorized calculations even better, though sometimes the code is uglier:
\end_layout

\begin_layout Chunk
<<chunk6>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1000000)
\end_layout

\begin_layout Chunk
benchmark(truncx <- ifelse(x > 0, x, 0),
\end_layout

\begin_layout Chunk
{truncx <- x; truncx[x < 0] <- 0},
\end_layout

\begin_layout Chunk
truncx <- x * (x > 0),
\end_layout

\begin_layout Chunk
replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The demo code (see also Section 4.2 of Unit 4) has a surprising example where
 combining vectorized calculations with a 
\emph on
for
\emph default
 loop is actually faster than using 
\emph on
apply()
\emph default
.
 The goal is to remove rows of a large matrix that have any NAs in them.
 
\end_layout

\begin_layout Standard
Additional tips:
\end_layout

\begin_layout Itemize
If you do need to loop over dimensions of a matrix or array, if possible
 loop over the smallest dimension and use the vectorized calculation on
 the larger dimension(s).
 
\end_layout

\begin_layout Itemize
Looping over columns is likely to be faster than looping over rows given
 column-major ordering.
\end_layout

\begin_layout Itemize
You can use direct arithmetic operations to add/subtract/multiply/divide
 a vector by each column of a matrix, e.g.
 
\family typewriter
A*b
\family default
, multiplies each column of 
\emph on
A
\emph default
 times a vector 
\emph on
b
\emph default
.
 If you need to operate by row, you can do it by transposing the matrix.
 
\end_layout

\begin_layout Standard
Caution: relying on R's recycling rule in the context of vectorized operations,
 such as is done when direct-multiplying a matrix by a vector to scale the
 rows, can be dangerous as the code is not transparent and poses greater
 dangers of bugs.
 If it's needed to speed up a calculation, the best approach is to (1) first
 write the code transparently and then compare the efficient code to make
 sure the results are the same and (2) comment your code.
\end_layout

\begin_layout Standard
Question: What do the points above imply about how to choose to store values
 in a matrix? How would you choose what should be the row dimension and
 what should be the column dimension? 
\end_layout

\begin_layout Subsubsection
Using 
\emph on
apply()
\emph default
 and specialized functions
\end_layout

\begin_layout Standard
Another core efficiency strategy is to use the 
\emph on
apply()
\emph default
 functionality.
 Even better than 
\emph on
apply()
\emph default
 for calculating sums or means of columns or rows (it also can be used for
 arrays) is 
\emph on
{row,col}{Sums,Means}
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk7>>=
\end_layout

\begin_layout Chunk
n <- 3000; x <- matrix(rnorm(n * n), nr = n)
\end_layout

\begin_layout Chunk
system.time(out <- apply(x, 1, mean))
\end_layout

\begin_layout Chunk
system.time(out <- rowMeans(x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can '
\emph on
sweep
\emph default
' out a summary statistic, such as subtracting off a mean from each column,
 using 
\emph on
sweep()
\end_layout

\begin_layout Chunk
<<chunk8>>=
\end_layout

\begin_layout Chunk
system.time(out <- sweep(x, 2, STATS = colMeans(x), FUN = "-"))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Here's a trick for doing it based on vectorized calculations, remembering
 that if we subtract a vector from a matrix, it subtracts each element of
 the vector from all the elements in the corresponding ROW.
\end_layout

\begin_layout Chunk
<<chunk9>>=
\end_layout

\begin_layout Chunk
system.time(out2 <- t(t(x) - colMeans(x)))
\end_layout

\begin_layout Chunk
identical(out, out2)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
As we've discussed using versions of 
\emph on
apply()
\emph default
 with lists may or may not be faster than looping but generally produces
 cleaner code.
 Whether looping is slower will depend on whether a substantial part of
 the work is in the overhead of the looping or in the time required by the
 function evaluation on each of the elements.
 If you're worried about speed, it's a good idea to benchmark the 
\emph on
apply()
\emph default
 variant against looping.
\end_layout

\begin_layout Subsubsection
Matrix algebra efficiency
\end_layout

\begin_layout Standard
Often calculations that are not explictly linear algebra calculations can
 be done as matrix algebra.
 The following can be done faster with 
\emph on
rowSums()
\emph default
, so it's not a great example, but this sort of trick does come in handy
 in surprising places.
\end_layout

\begin_layout Chunk
<<chunk10>>=
\end_layout

\begin_layout Chunk
mat <- matrix(rnorm(500*500), 500)
\end_layout

\begin_layout Chunk
benchmark(apply(mat, 1, sum),
\end_layout

\begin_layout Chunk
	mat %*% rep(1, ncol(mat)),
\end_layout

\begin_layout Chunk
	rowSums(mat),
\end_layout

\begin_layout Chunk
	replications = 10, columns=c('test', 'elapsed', 'replications'))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
On the other hand, big matrix operations can be slow.
 Suppose you want a new matrix that computes the differences between successive
 columns of a matrix of arbitrary size.
 How would you do this as matrix algebra operations? [see demo code] Here
 it turns out that the 
\emph on
for
\emph default
 loop is much faster than matrix multiplication.
 However, there is a way to do it faster as matrix direct subtraction.
 Comment: the demo code also contains some exploration of different ways
 of creating patterned matrices.
 Note that this level of optimization is only worth it if you're doing something
 over and over again, or writing code that you will distribute.
\end_layout

\begin_layout Standard
When doing matrix algebra, the order in which you do operations can be critical
 for efficiency.
 How should I order the following calculation?
\end_layout

\begin_layout Chunk
<<chunk11, cache=TRUE>>=
\end_layout

\begin_layout Chunk
n <- 5000
\end_layout

\begin_layout Chunk
A <- matrix(rnorm(5000 * 5000), 5000)
\end_layout

\begin_layout Chunk
B <- matrix(rnorm(5000 * 5000), 5000)
\end_layout

\begin_layout Chunk
x <- rnorm(5000)
\end_layout

\begin_layout Chunk
res <- A %*% B %*% x
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can use the matrix direct product (i.e., 
\family typewriter
A*B
\family default
) to do some manipulations much more quickly than using matrix multiplication.
 
\series bold
Challenge
\series default
: How can I use the direct product to find the trace of a matrix, 
\begin_inset Formula $XY$
\end_inset

? 
\begin_inset Note Note
status open

\begin_layout Plain Layout
sum(X*t(Y))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can generally get much faster results by being smart when using diagonal
 matrices.
 Here are some examples, where we avoid directly doing: 
\begin_inset Formula $X+D$
\end_inset

, 
\begin_inset Formula $DX$
\end_inset

, 
\begin_inset Formula $XD$
\end_inset

:
\end_layout

\begin_layout Chunk
<<chunk12>>=
\end_layout

\begin_layout Chunk
n <- 1000
\end_layout

\begin_layout Chunk
X <- matrix(rnorm(n^2), n) 
\end_layout

\begin_layout Chunk
diagvals <- rnorm(n)
\end_layout

\begin_layout Chunk
D = diag(diagvals)
\end_layout

\begin_layout Chunk
diag(X) <- diag(X) + diagvals
\end_layout

\begin_layout Chunk
tmp <- diagvals * X # instead of D %*% X
\end_layout

\begin_layout Chunk
tmp2 <- t(t(X) * diagvals) # instead of X %*% D
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
More generally, sparse matrices and structured matrices (such as block diagonal
 matrices) can generally be worked with MUCH more efficiently than treating
 them as arbitrary matrices.
 The 
\emph on
spam
\emph default
 (for arbitrary sparse matrices), 
\emph on
bdsmatrix
\emph default
 (for block-diagonal matrices), and 
\emph on
Matrix
\emph default
 (for a variety of sparse matrix types) packages in R can help, as can specializ
ed code available in other languages, such as C and Fortran packages.
\end_layout

\begin_layout Subsubsection
Fast mapping/lookup tables
\end_layout

\begin_layout Standard
Sometimes you need to map between two vectors.
 E.g., 
\begin_inset Formula $y_{ij}\sim\mathcal{N}(\mu_{j},\sigma^{2})$
\end_inset

 is a basic ANOVA type structure.
 Here are some efficient ways to aggregate to the cluster level and disaggregate
 to the observation level.
\end_layout

\begin_layout Standard
Disaggregate: Create a vector, 
\emph on
idVec
\emph default
, that gives a numeric mapping of the observations to their cluster.
 Then you can access the 
\begin_inset Formula $\mu$
\end_inset

 value relevant for each observation as:
\family typewriter
\series bold
 
\series default
mus[idVec]
\family default
.
\end_layout

\begin_layout Standard
Aggregate: To find the sample means by cluster
\family typewriter
: sapply(split(dat$obs, idVec), mean)
\end_layout

\begin_layout Standard
As we've seen R allows you to look up elements of vector by name.
 For example:
\end_layout

\begin_layout Chunk
<<chunk13>>=
\end_layout

\begin_layout Chunk
vals <- rnorm(10)
\end_layout

\begin_layout Chunk
names(vals) <- letters[1:10]
\end_layout

\begin_layout Chunk
select <- c("h", "h", "a", "c")
\end_layout

\begin_layout Chunk
vals[select]
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can do similar things in terms of looking up by name with dimension
 names of matrices/arrays, row and column names of dataframes, and named
 lists.
\end_layout

\begin_layout Standard
However, looking things up by name can be slow relative to looking up by
 index.
\end_layout

\begin_layout Chunk
<<chunk13a>>=
\end_layout

\begin_layout Chunk
n=1000000
\end_layout

\begin_layout Chunk
x <- 1:n
\end_layout

\begin_layout Chunk
xL <- as.list(x)
\end_layout

\begin_layout Chunk
nms <- as.character(x)
\end_layout

\begin_layout Chunk
names(x) <- nms
\end_layout

\begin_layout Chunk
names(xL) <- nms
\end_layout

\begin_layout Chunk
benchmark(x[500000], x["500000"], xL[[500000]], xL[["500000"]], replications
 = 10)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Standard
Why do you think it is slow to look things up by name?
\begin_inset Note Note
status open

\begin_layout Plain Layout
 lack of ordering - R need to scan through each name and check if it's the
 one
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Hashing
\end_layout

\begin_layout Standard
A hash function is a function that takes as input some data and maps it
 to a fixed-length output that can be used as a shortened reference to the
 data.
 We've seen this in the context of git commits where each commit was labeled
 with a long base-16 number.
 This also comes up when verifying files on the Internet.
 You can compute the hash value on the file you get and check that it is
 the same as the hash value associated with the legitimate copy of the file.
\end_layout

\begin_layout Standard
For our purposes here, hashing can allow one to look up values by their
 name via a hash table.
 The idea is that you have a set of key-value pairs (sometimes called a
 dictionary) where the key is the name associated with the value and the
 value is some arbitrary object.
 Hashing allows one to quickly determine an index associated with the key
 and therefore quickly find the relevant value based on the index.
 For example, one approach is to compute the hash as a function of the key
 and then take the remainder when dividing by the number of possible hash
 values to get the index.
 In general, the number of unique keys will be larger than the number of
 unique indices, so there will be collisions [I neglected to make this clear
 in Unit 2, where I said the result of the hash function would be unique],
 but usually there will be a small number of keys associated with a given
 index or slot, and determining the correct value within a given index/slot
 (also called a bucket) is fast.
 Put another way, the hash function distributes the keys amongst an array
 of buckets and allows one to look up the appropriate bucket quickly based
 on the computed index value.
 When the hash table is properly set up, the cost of looking up a value
 does not depend on the number of key-value pairs stored.
\end_layout

\begin_layout Standard
As can be inferred from 
\family typewriter
?environment
\family default
 and according to Adler, looking up objects by name (i.e., looking up symbols)
 within an R environment is implemented using hashing, so it can be very
 fast (in the example here, it is only slightly slower than looking up by
 index, with some overhead associated with computing the hash value).
\end_layout

\begin_layout Chunk
<<chunk13b, cache=TRUE>>=
\end_layout

\begin_layout Chunk
xEnv <- as.environment(xL)  # convert from a named list
\end_layout

\begin_layout Chunk
xEnv$"500000"  
\end_layout

\begin_layout Chunk
# I need quotes above because numeric; otherwise xEnv$nameOfObject is fine
\end_layout

\begin_layout Chunk
xEnv[["500000"]]
\end_layout

\begin_layout Chunk
benchmark(x[500000], xL[[500000]], xEnv[["500000"]], xEnv$"500000", replications
 = 10000) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsubsection
pqR and other R engines
\end_layout

\begin_layout Standard
Radford Neal, a prominent statistician/computer scientist has been working
 on a project called 
\emph on
pqR
\emph default
 (pretty quick R) to rewrite some aspects of R to make them faster.
 There are also a few other projects that aim to reimplement the 
\begin_inset Quotes eld
\end_inset

R engine
\begin_inset Quotes erd
\end_inset

 such that one could run one's R code with different back ends.
\end_layout

\begin_layout Standard
Here are some of the highlights of 
\emph on
pqR
\emph default
 in terms of efficiency, as discussed at 
\begin_inset CommandInset href
LatexCommand href
target "http://radfordneal.github.io/pqR/"

\end_inset

:
\end_layout

\begin_layout Enumerate
When R runs code such as just below, it actually creates a vector 1,2,....,n,
 (which can be computationally and memory intensive for large n) and then
 iterates over the values in the vector.
 pqR avoids this vector creation.
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
for(i in 1:n) { }
\begin_inset Newline newline
\end_inset

vec[1:n]
\end_layout

\end_deeper
\begin_layout Enumerate
As we'll see in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lazy-evaluation,-delayed"

\end_inset

, R often avoids making copies of objects when it is not necessary.
 However, the scheme used to do this can be improved so that even fewer
 copies are made.
\end_layout

\begin_layout Enumerate
pqR automatically uses multiple cores for some calculations.
\end_layout

\begin_layout Enumerate
pqR avoid some checks for NA and NaN and the like in matrix calculations
 in which such checking would be slow and it doesn't make sense to check
 for them anyway.
\end_layout

\begin_layout Subsubsection
Byte compiling
\end_layout

\begin_layout Standard
R now allows you to compile R code, which goes by the name of byte compiling.
 Byte-compiled code is a special representation that can be executed more
 efficiently because it is in the form of compact codes that encode the
 results of parsing and semantic analysis of scoping and other complexities
 of the R source code.
 This byte code can be executed faster than the original R code because
 it skips the stage of having to be interpreted by the R interpreter.
\end_layout

\begin_layout Standard
The functions in the 
\emph on
base
\emph default
 and 
\emph on
stats
\emph default
 packages are now byte-compiled by default.
 (If you print out a function that is byte-compiled, you'll see something
 like 
\emph on
<bytecode: 0x243a368>
\emph default
 at the bottom.
\end_layout

\begin_layout Standard
We can byte compile our own functions using 
\emph on
cmpfun()
\emph default
.
 Here's an example (silly since we we actually do this calculation using
 vectorized operations):
\end_layout

\begin_layout Chunk
<<chunk14, cache=TRUE>>=
\end_layout

\begin_layout Chunk
library(compiler); library(rbenchmark)
\end_layout

\begin_layout Chunk
f <- function(x){
\end_layout

\begin_layout Chunk
	for(i in 1:length(x)) x[i] <- x[i] + 1
\end_layout

\begin_layout Chunk
	return(x)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
fc <- cmpfun(f)
\end_layout

\begin_layout Chunk
fc # notice the indication that the function is byte compiled.
\end_layout

\begin_layout Chunk
x <- rnorm(100000)
\end_layout

\begin_layout Chunk
benchmark(f(x), fc(x), x <- x + 1, replications = 5)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can compile an entire source file with 
\emph on
cmpfile()
\emph default
, which produces a 
\emph on
.Rc
\emph default
 file.
 You then need to use 
\emph on
loadcmp()
\emph default
 to load in the 
\emph on
.Rc
\emph default
 file, which runs the code.
\end_layout

\begin_layout Standard
Unfortunately, in my experience, byte compiling doesn't usually speed things
 up much.
 As experienced R programmers we would never write the unvectorized code
 above.
\end_layout

\begin_layout Subsection
Challenges
\end_layout

\begin_layout Standard
One or more of these challenges may appear on a problem set.
\end_layout

\begin_layout Standard

\series bold
Challenge 1
\series default
: here's a calculation of the sort needed in mixture component modeling.
 I have a vector of 
\begin_inset Formula $n$
\end_inset

 observations.
 I need to find the likelihood of each observation under each of 
\begin_inset Formula $p$
\end_inset

 mixture components (i.e., what's the likelihood if it came from each of the
 components).
 So I should produce a matrix of 
\begin_inset Formula $n$
\end_inset

 rows and 
\begin_inset Formula $p$
\end_inset

 columns where the value in the 
\begin_inset Formula $i$
\end_inset

th row, 
\begin_inset Formula $j$
\end_inset

th column is the likelihood of the 
\begin_inset Formula $i$
\end_inset

th observation under the 
\begin_inset Formula $j$
\end_inset

th mixture component.
 The idea is that the likelihoods for a given observation are used in assigning
 observations to clusters.
 A naive implementation is:
\end_layout

\begin_layout Standard

\family typewriter
> lik <- matrix(NA, nr = n, nc = p)
\end_layout

\begin_layout Standard

\family typewriter
> for(j in 1:p) lik[ , j] <- dnorm(y, mns[j], sds[j])
\family default

\begin_inset Newline newline
\end_inset

Note that 
\emph on
dnorm()
\emph default
 can handle matrices and vectors as the observations 
\series bold
and
\series default
 as the means and sds, so there are multiple ways to do this.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[mixtureExample.q]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 2
\series default
: Suppose you have 
\begin_inset Formula $y_{i}\sim\mathcal{N}(\sum_{k=1}^{m_{i}}w_{i,k}\mu_{ID[i,k]},\sigma^{2})$
\end_inset

 for a large number of observations, 
\begin_inset Formula $n$
\end_inset

.
 I give you a vector of 
\begin_inset Formula $\mu$
\end_inset

 values and a ragged list of weights and a ragged list of IDs identifying
 the cluster corresponding to each weight (note 
\begin_inset Formula $m_{i}$
\end_inset

 varies by observation); this is a mixed membership type model.
 Figure out how to calculate the vector of means, 
\begin_inset Formula $\sum_{k}w_{i,k}\mu_{ID[i,k]}$
\end_inset

 as fast as possible.
 Suppose that 
\begin_inset Formula $m_{i}$
\end_inset

 never gets too big (but 
\begin_inset Formula $\mu$
\end_inset

 might have many elements) - could this help you? Part of thinking this
 through involves thinking about how you want to store the information so
 that the calculations can be done quickly.
\end_layout

\begin_layout Standard

\series bold
Challenge 3
\series default
: Write code that simulates a random walk in two dimensions for 
\begin_inset Formula $n$
\end_inset

 steps.
 First write out a straightforward implementation that involves looping.
 Then try to speed it up.
 The 
\emph on
cumsum()
\emph default
 function may be helpful.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Extra: simulate an excited random walk.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 4:
\series default
 Determine if it's faster to subset based on vector of indices or a vector
 of logicals.
 Determine if it matters how big the original object is and how large the
 subset is, as well as whether the vector of indices is ordered.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sometimes we can avoid dealing with indexing by using vectorized mathematical
 operations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Have them look at Duncan's random walk example.
 Or perhaps do as part of profiling section.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Advanced topics in working with functions
\end_layout

\begin_layout Subsection
Pointers
\end_layout

\begin_layout Standard
By way of contrast to R's pass by value system, I want to briefly discuss
 the idea of a pointer, common in compiled languages such as C.
\end_layout

\begin_layout Standard

\family typewriter
int x = 3;
\end_layout

\begin_layout Standard

\family typewriter
int* ptr;
\end_layout

\begin_layout Standard

\family typewriter
ptr = &x;
\end_layout

\begin_layout Standard

\family typewriter
*ptr * 7; // returns 21
\end_layout

\begin_layout Standard
Here 
\emph on
ptr
\emph default
 is the address of the integer 
\emph on
x
\emph default
.
 
\end_layout

\begin_layout Standard
Vectors in C are really pointers to a block of memory:
\end_layout

\begin_layout Standard

\family typewriter
int x[10];
\end_layout

\begin_layout Standard
In this case 
\emph on
x
\emph default
 will be the address of the first element of the vector.
 We can access the first element as 
\family typewriter
x[0]
\family default
 or 
\family typewriter
*x
\family default
.
\end_layout

\begin_layout Standard
Why have we gone into this? In C, you can pass a pointer as an argument
 to a function.
 The result is that only the scalar address is copied and not the entire
 vector, and inside the function, one can modify the original vector, with
 the new value persisting on exit from the function.
 For example:
\end_layout

\begin_layout Standard

\family typewriter
int myCal(int *ptr){
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

*ptr = *ptr + *ptr;
\end_layout

\begin_layout Standard

\family typewriter
}
\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
 [draw picture of memory location of y with two pointers to it, one local
 and one global]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When calling C or C++ from R, one (implicitly) passes pointers to the vectors
 into C.
 Let's see an example:
\end_layout

\begin_layout Standard

\family typewriter
out <- rep(0, n)
\end_layout

\begin_layout Standard

\family typewriter
out <- .C(
\begin_inset Quotes eld
\end_inset

logLik
\begin_inset Quotes erd
\end_inset

, out = as.double(out), 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

theta = as.double(theta))$out
\family default

\begin_inset Newline newline
\end_inset

In C, the function definition looks like this:
\end_layout

\begin_layout Standard

\family typewriter
void logLik(double* out, double* theta)
\end_layout

\begin_layout Subsection
Alternatives to pass by value in R
\end_layout

\begin_layout Standard
There are occasions we do not want to pass by value.
 The main reason is when we want a function to modify a complicated object
 without having to return it and re-assign it in the parent environment.
 There are several work-arounds:
\end_layout

\begin_layout Enumerate
We can use Reference Class objects.
 Reference classes are new in R.
 We'll discuss these in Section 4.
\end_layout

\begin_layout Enumerate
We can access the object in the enclosing environment as a 'global variable',
 as we've seen when discussing scoping.
 More generally we can access the object using 
\emph on
get()
\emph default
, specifying the environment from which we want to obtain the variable.
 Recall that to specify the location of an object, we can generally specify
 (1) a position in the search path, (2) an explicit environment, or (3)
 a location in the call stack by using 
\emph on
sys.frame()
\emph default
.
 However we cannot change the value of the object in the parent environment
 without some additional tools.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
We can use the '<<-' operator to assign into an object in the parent environment
 (provided an object of that name exists in the parent environment).
 
\end_layout

\begin_layout Enumerate
We can also use 
\emph on
assign()
\emph default
, specifying the environment in which we want the assignment to occur.
\end_layout

\end_deeper
\begin_layout Enumerate
We can use replacement functions (Section 2.4), which hide the reassignment
 in the parent environment from the user.
 Note that a second copy is generally created in this case, but the original
 copy is quickly removed.
\end_layout

\begin_layout Enumerate
We can use a closure.
 This involves creating functions within a function call and returning the
 functions as a list (or a single function, as we saw when discussing scoping
 in Unit 4).
 When one executes the enclosing function, the list is created and one can
 call the functions of that object.
 Those functions then can access objects in the enclosing environment (the
 environment of the original function) and can use `<<-` to assign into
 the enclosing environment, to which all the functions have access.
 Chambers provides an example of this in Sec.
 5.4.
\begin_inset Newline newline
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
[[[perhaps see http://www.r-bloggers.com/function-closures-and-s4-methods/?utm_sou
rce=feedburner&utm_medium=email&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29
 for S4 and closures ]]]
\end_layout

\end_inset


\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
<<chunk15>>=
\end_layout

\begin_layout Chunk
x <- rnorm(10)
\end_layout

\begin_layout Chunk
f <- function(input){
\end_layout

\begin_layout Chunk
	data <- input
\end_layout

\begin_layout Chunk
	g <- function(param) return(param * data) 
\end_layout

\begin_layout Chunk
	return(g)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
myFun <- f(x)
\end_layout

\begin_layout Chunk
rm(x) # to demonstrate we no longer need x
\end_layout

\begin_layout Chunk
myFun(3)
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
myFun <- f(x)
\end_layout

\begin_layout Chunk
object.size(myFun) # hmmm
\end_layout

\begin_layout Chunk
object.size(environment(myFun)$data)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Here's a fun example.
 You might do this with an 
\emph on
apply()
\emph default
 variant, in particular 
\emph on
replicate()
\emph default
, but this is slick:
\end_layout

\begin_layout Chunk
<<chunk15a>>=
\end_layout

\begin_layout Chunk
make_container <- function(n) {
\end_layout

\begin_layout Chunk
	x <- numeric(n)
\end_layout

\begin_layout Chunk
	i <- 1
\end_layout

\begin_layout Chunk
	
\end_layout

\begin_layout Chunk
	function(value = NULL) {
\end_layout

\begin_layout Chunk
		if (is.null(value)) {
\end_layout

\begin_layout Chunk
			return(x)
\end_layout

\begin_layout Chunk
		} else {
\end_layout

\begin_layout Chunk
			x[i] <<- value
\end_layout

\begin_layout Chunk
			i <<- i + 1
\end_layout

\begin_layout Chunk
		}	 
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
nboot <- 100
\end_layout

\begin_layout Chunk
bootmeans <- make_container(nboot)
\end_layout

\begin_layout Chunk
data <- faithful[ , 1] # length of Old Faithful geyser eruption times
\end_layout

\begin_layout Chunk
for (i in 1:nboot)
\end_layout

\begin_layout Chunk
	bootmeans(mean(sample(data, length(data),
\end_layout

\begin_layout Chunk
      replace=TRUE)))
\end_layout

\begin_layout Chunk
# this will place results in x in the function env't and you can grab it
 out as
\end_layout

\begin_layout Chunk
bootmeans()
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Itemize
A related approach is to wrap data with a function using 
\emph on
with()
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This approach appeared in Problem Set 2.
 (Fall2012)
\end_layout

\end_inset


\end_layout

\begin_layout Chunk
<<chunk16>>=
\end_layout

\begin_layout Chunk
x <- rnorm(10)
\end_layout

\begin_layout Chunk
myFun2 <- with(list(data = x), function(param) return(param * data))
\end_layout

\begin_layout Chunk
rm(x)
\end_layout

\begin_layout Chunk
myFun2(3)
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
myFun2 <- with(list(data = x), function(param) return(param * data))
\end_layout

\begin_layout Chunk
object.size(myFun2)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Question
\series default
: When would it be useful to have an object carried along with a function
 as done here?
\end_layout

\begin_layout Subsection
Operators
\end_layout

\begin_layout Standard
Operators, such as '
\family typewriter
\emph on
+
\family default
\emph default
', '
\emph on
[
\emph default
' are just functions, but their arguments can occur both before and after
 the function call:
\end_layout

\begin_layout Chunk
<<chunk17, tidy=FALSE>>=
\end_layout

\begin_layout Chunk
a <- 7; b <- 3
\end_layout

\begin_layout Chunk
# let's think about the following as a mathematical function
\end_layout

\begin_layout Chunk
#  -- what's the function call?
\end_layout

\begin_layout Chunk
a + b 
\end_layout

\begin_layout Chunk
`+`(a, b)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
In general, you can use back-ticks to refer to the operators as operators
 instead of characters.
 In some cases single or double quotes also work.
 We can look at the code of an operator as follows using back-ticks to escape
 out of the standard R parsing, e.g., 
\family typewriter
`%*%`.
\end_layout

\begin_layout Standard
Finally, since an operator is just a function, you can use it as an argument
 in various places:
\end_layout

\begin_layout Chunk
<<chunk18>>=
\end_layout

\begin_layout Chunk
myList = list(list(a = 1:5, b = "sdf"), list(a = 6:10, b = "wer"))
\end_layout

\begin_layout Chunk
myMat = sapply(myList, `[[`, 1) 
\end_layout

\begin_layout Chunk
# note that the index "1" is the additional argument to the [[ function
\end_layout

\begin_layout Chunk
x <- 1:3; y <- c(100,200,300)
\end_layout

\begin_layout Chunk
outer(x, y, `+`)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can define your own 
\emph on
binary
\emph default
 operator (an operator taking two arguments) using a string inside 
\emph on
%
\emph default
 symbols:
\end_layout

\begin_layout Chunk
<<chunk19>>=
\end_layout

\begin_layout Chunk
`%2%` <- function(a, b) {2 * (a + b)}
\end_layout

\begin_layout Chunk
3 %2% 7
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Since operators are just functions, there are cases in which there are optional
 arguments that we might not expect.
 We've already briefly seen the 
\emph on
drop
\emph default
 argument to the `[` operator:
\end_layout

\begin_layout Chunk
<<chunk20>>=
\end_layout

\begin_layout Chunk
mat <- matrix(1:4, 2, 2)
\end_layout

\begin_layout Chunk
mat[ , 1] 
\end_layout

\begin_layout Chunk
mat[ , 1, drop = FALSE] # what's the difference?
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Unexpected functions and replacement functions
\end_layout

\begin_layout Standard
All code in R can be viewed as a function call.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The subset assignment operator is '[<-'.
 
\end_layout

\begin_layout Plain Layout
> animals <- c("cow", "chicken", "pig", "tuba")
\end_layout

\begin_layout Plain Layout
> '[<-'(animals, 4, 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset

So animals[4] <- 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

 is actually parsed by R to run the code above.
 We'll talk about expression parsing a bit later.
 Note that the parser has to be clever enough to realize that the animals
 argument comes before the operator syntax and the '4' argument is in the
 middle of it.
 
\end_layout

\begin_layout Plain Layout
Challenge: How could you write R code that itself parses an R statement
 such as animals[4] <- 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What do you think is the functional version of the following code? What
 are the arguments?
\end_layout

\begin_layout Chunk
<<chunk21, eval = FALSE>>=
\end_layout

\begin_layout Chunk
if(x > 27){
\end_layout

\begin_layout Chunk
	print(x)	
\end_layout

\begin_layout Chunk
} else{
\end_layout

\begin_layout Chunk
	print("too small") 
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Assignments that involve functions or operators on the left-hand side (LHS)
 are called 
\emph on
replacement expressions
\emph default
 or 
\emph on
replacement functions.
 
\emph default
These can be quite handy.
 Here are a few examples:
\end_layout

\begin_layout Chunk
<<chunk22, eval = FALSE>>=
\end_layout

\begin_layout Chunk
diag(mat) <- c(3, 2)
\end_layout

\begin_layout Chunk
is.na(vec) <- 3
\end_layout

\begin_layout Chunk
names(df) <- c('var1', 'var2')
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Replacement expressions are actually function calls.
 The R interpreter calls the replacement function (which often creates a
 new object that includes the replacement) and then assigns the result to
 the name of the original object.
\end_layout

\begin_layout Chunk
<<chunk23>>=
\end_layout

\begin_layout Chunk
mat <- matrix(rnorm(4), 2, 2)
\end_layout

\begin_layout Chunk
diag(mat) <- c(3, 2)
\end_layout

\begin_layout Chunk
mat <- `diag<-`(mat, c(10, 21))
\end_layout

\begin_layout Chunk
base::`diag<-`
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The old version of 
\emph on
mat
\emph default
 still exists until R's memory management cleans it up, but it's no longer
 referred to by the symbol '
\emph on
mat
\emph default
'.
 Occasionally this sort of thing might cause memory usage to increase (for
 example it's possible if you're doing replacements on large objects within
 a loop), but in general things should be fine.
\end_layout

\begin_layout Standard
You can define your own replacement functions like this, with the requirements
 that the last argument be named '
\emph on
value
\emph default
' and that the function return the entire object:
\end_layout

\begin_layout Chunk
<<chunk24>>=
\end_layout

\begin_layout Chunk
me <- list(name = 'Chris', age = 25)
\end_layout

\begin_layout Chunk
`name<-` <- function(obj, value){
\end_layout

\begin_layout Chunk
obj$name <- value
\end_layout

\begin_layout Chunk
return(obj)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
name(me) <- 'Christopher'
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Functions as objects
\end_layout

\begin_layout Standard
Note that a function is just an object.
\end_layout

\begin_layout Chunk
<<chunk25>>=
\end_layout

\begin_layout Chunk
x <- 3
\end_layout

\begin_layout Chunk
x(2)
\end_layout

\begin_layout Chunk
x <- function(z) z^2
\end_layout

\begin_layout Chunk
x(2)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can call a function based on the text name of the function.
 
\end_layout

\begin_layout Chunk
<<chunk26>>=
\end_layout

\begin_layout Chunk
myFun = 'mean'; x = rnorm(10)
\end_layout

\begin_layout Chunk
eval(as.name(myFun))(x)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can also pass a function into another function either as the actual function
 object or as a character vector of length one with the name of the function.
 Here 
\emph on
match.fun()
\emph default
 is a handy function that extracts a function when the function is passed
 in as an argument of a function.
 It looks in the calling environment for the function and can handle when
 the function is passed in as a function object or as a character vector
 of length 1 giving the function name.
\end_layout

\begin_layout Chunk
<<chunk27>>=
\end_layout

\begin_layout Chunk
f <- function(fxn, x){
\end_layout

\begin_layout Chunk
	match.fun(fxn)(x) 
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
f("mean", x)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
This allows us to write functions in which the user passes in the function
 (as an example, this works when using 
\emph on
outer()
\emph default
).
 Caution: one may need to think carefully about scoping issues in such contexts.
\end_layout

\begin_layout Standard
Function objects contain three components: an argument list, a body (a parsed
 R statement), and an environment.
\end_layout

\begin_layout Chunk
<<chunk28>>=
\end_layout

\begin_layout Chunk
f <- function(x) x
\end_layout

\begin_layout Chunk
f2 <- function(x) y <- x^2
\end_layout

\begin_layout Chunk
f3 <- function(x) {y <- x^2; z <- x^3; return(list(y, z))}
\end_layout

\begin_layout Chunk
class(f)
\end_layout

\begin_layout Chunk
typeof(body(f)); class(body(f))
\end_layout

\begin_layout Chunk
typeof(body(f2)); class(body(f2))
\end_layout

\begin_layout Chunk
typeof(body(f3)); class(body(f3))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We'll see more about objects relating to the R language and parsed code
 in a later section.
 For now, just realize that the parsed code itself is treated as an object(s)
 with certain types and certain classes.
\end_layout

\begin_layout Standard
We can extract the argument object as
\end_layout

\begin_layout Chunk
<<chunk29>>=
\end_layout

\begin_layout Chunk
f4 <- function(x, y = 2, z = 1/y) {x + y + z}
\end_layout

\begin_layout Chunk
args <- formals(f4)
\end_layout

\begin_layout Chunk
args
\end_layout

\begin_layout Chunk
class(args)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
A 
\emph on
pairlist 
\emph default
is like a list, but with pairing that in this case pairs argument names
 with default values.
\end_layout

\begin_layout Subsection
Promises and lazy evaluation
\end_layout

\begin_layout Standard
One additional concept that it's useful to be aware of is the idea of a
 
\emph on
promise
\emph default
 object.
 In function calls, when R matches user input arguments to formal argument
 names, it does not (usually) evaluate the arguments until they are needed,
 which is called 
\emph on
lazy evaluation
\emph default
.
 Instead the formal arguments are of a special type called a 
\emph on
promise
\emph default
.
 Let's see lazy evaluation in action.
 Do you think the following code will run?
\end_layout

\begin_layout Chunk
<<chunk30, eval=FALSE>>=
\end_layout

\begin_layout Chunk
f <- function(a, b = c) {
\end_layout

\begin_layout Chunk
	c <- log(a); 
\end_layout

\begin_layout Chunk
	return(a*b)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
f(7)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
What's strange about that? 
\end_layout

\begin_layout Standard
Another example:
\end_layout

\begin_layout Chunk
<<chunk31>>=
\end_layout

\begin_layout Chunk
f <- function(x) print("hi")
\end_layout

\begin_layout Chunk
system.time(mean(rnorm(1000000)))
\end_layout

\begin_layout Chunk
system.time(f(3))
\end_layout

\begin_layout Chunk
system.time(f(mean(rnorm(1000000)))) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Evaluating memory use
\end_layout

\begin_layout Standard
The main things to remember when thinking about memory use are: (1) numeric
 vectors take 8 bytes per element and (2) we need to keep track of when
 large objects are created, including in the frames of functions.
\end_layout

\begin_layout Subsection
Allocating and freeing memory
\end_layout

\begin_layout Standard
Unlike compiled languages like C, in R we do not need to explicitly allocate
 storage for objects.
 However, we have seen that there are times that we do want to allocate
 storage in advance, rather than successively concatenating onto a larger
 object.
 
\end_layout

\begin_layout Standard
R automatically manages memory, releasing memory back to the operating system
 when it's not needed via garbage collection.
 Occasionally you will want to remove large objects as soon as they are
 not needed.
 
\emph on
rm()
\emph default
 does not actually free up memory, it just disassociates the name from the
 memory used to store the object.
 In general R will clean up such objects without a reference (i.e., a name)
 but you may need to call 
\emph on
gc()
\emph default
 to force the garbage collection.
 This uses some computation so it's generally not recommended.
\end_layout

\begin_layout Standard
In a language like C in which the user allocates and frees up memory, memory
 leaks are a major cause of bugs.
 Basically if you are looping and you allocate memory at each iteration
 and forget to free it, the memory use builds up inexorably and eventually
 the machine runs out of memory.
 In R, with automatic garbage collection, this is generally not an issue,
 but occasionally memory leaks do occur.
 
\end_layout

\begin_layout Subsection
Monitoring overall memory use
\end_layout

\begin_layout Standard
There are a number of ways to see how much memory is being used.
 When R is actively executing statements, you can use 
\emph on
top
\emph default
 from the UNIX shell.
 In R, 
\emph on
gc()
\emph default
 reports memory use and free memory as 
\emph on
Ncells
\emph default
 and 
\emph on
Vcells
\emph default
.
 As far as I know, 
\emph on
Ncells
\emph default
 concerns the overhead of running R and 
\emph on
Vcells
\emph default
 relates to objects created by the user, so you'll want to focus on 
\emph on
Vcells
\emph default
.
 You can see the number of Mb currently used (the 
\begin_inset Quotes eld
\end_inset


\emph on
used
\emph default

\begin_inset Quotes erd
\end_inset

 column of the output) and the maximum used in the session (the 
\begin_inset Quotes eld
\end_inset


\emph on
max used
\emph default

\begin_inset Quotes erd
\end_inset

 column)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Chunk
<<chunk31a>>=
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
x <- rnorm(1e8) # should use about 800 Mb
\end_layout

\begin_layout Chunk
object.size(x)
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
rm(x)
\end_layout

\begin_layout Chunk
gc() # note the "max used" column
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
In Windows only, 
\emph on
memory.size()
\emph default
 tells how much memory is being used.
 
\end_layout

\begin_layout Standard
You can check the amount of memory used by individual objects with 
\emph on
object.size()
\emph default
.
\end_layout

\begin_layout Standard
Here is a useful function, 
\emph on
ls.sizes()
\emph default
, that wraps 
\emph on
object.size()
\emph default
 to report the largest 
\begin_inset Formula $n$
\end_inset

 objects in a given environment:
\end_layout

\begin_layout Chunk
<<chunk, ls.sizes>>=
\end_layout

\begin_layout Chunk
ls.sizes <- function(howMany = 10, minSize = 1){
\end_layout

\begin_layout Chunk
	pf <- parent.frame()
\end_layout

\begin_layout Chunk
	obj <- ls(pf) # or ls(sys.frame(-1)) 
\end_layout

\begin_layout Chunk
	objSizes <- sapply(obj, function(x) {
\end_layout

\begin_layout Chunk
	object.size(get(x, pf))})
\end_layout

\begin_layout Chunk
	# or sys.frame(-4) to get out of FUN, lapply(), sapply() and sizes()
\end_layout

\begin_layout Chunk
	objNames <- names(objSizes)
\end_layout

\begin_layout Chunk
	howmany <- min(howMany, length(objSizes))
\end_layout

\begin_layout Chunk
	ord <- order(objSizes, decreasing = TRUE)
\end_layout

\begin_layout Chunk
	objSizes <- objSizes[ord][1:howMany]
\end_layout

\begin_layout Chunk
	objSizes <- objSizes[objSizes > minSize]
\end_layout

\begin_layout Chunk
	objSizes <- matrix(objSizes, ncol = 1)
\end_layout

\begin_layout Chunk
	rownames(objSizes) <- objNames[ord][1:length(objSizes)]
\end_layout

\begin_layout Chunk
	colnames(objSizes) <- "bytes"
\end_layout

\begin_layout Chunk
	cat('object')
\end_layout

\begin_layout Chunk
	print(format(objSizes, justify = "right", width = 11), quote = FALSE)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[not needed for Fall2012 as it was a PS2 problem]
\end_layout

\end_inset

One frustration with memory management is that if your code bumps up against
 the memory limits of the machine, it can be very slow to respond even when
 you're trying to cancel the statement with 
\emph on
Ctrl-C
\emph default
.
 You can impose memory limits in Linux by starting R (from the UNIX prompt)
 in a fashion such as this
\end_layout

\begin_layout Standard

\family typewriter
> R --max-vsize=1000M
\family default

\begin_inset Newline newline
\end_inset

Then if you try to create an object that will push you over that limit or
 execute code that involves going over the limit, it will simply fail with
 the message 
\begin_inset Quotes eld
\end_inset


\emph on
Error: vector memory exhausted (limit reached?)
\emph default

\begin_inset Quotes erd
\end_inset

.
 So this approach may be a nice way to avoid paging/swapping by setting
 the maximum in relation to the physical memory of the machine.
 It might also help in debugging memory leaks because the program would
 fail at the point that memory use was increasing.
 I haven't played around with this much, so offer this with a note of caution.
\end_layout

\begin_layout Standard
We can use an internal function called 
\emph on
inspect()
\emph default
 to see where in memory an object is stored.
 We'll see that this can be a handy tool for seeing where copies are made
 and where they are not.
\end_layout

\begin_layout Chunk
<<chunk31aa>>=
\end_layout

\begin_layout Chunk
a <- rnorm(5)
\end_layout

\begin_layout Chunk
.Internal(inspect(a))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Hidden uses of memory
\end_layout

\begin_layout Itemize
Replacement functions can hide the use of additional memory.
 How much memory is used here?
\end_layout

\begin_layout Chunk
<<chunk32, eval=FALSE>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
dim(x) <- c(1e4, 1e3)
\end_layout

\begin_layout Chunk
diag(x) <- 1
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Itemize
Not all replacement functions actually involve creating a new object and
 replacing the original object.
\end_layout

\begin_layout Chunk
<<chunk33, eval=TRUE>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
x[5] <- 7
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Itemize
Indexing large subsets can involve a lot of memory use.
\end_layout

\begin_layout Chunk
<<chunk34, eval=FALSE>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
y <- x[1:(length(x) - 1)]
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Why was more memory used than just for 
\emph on
x
\emph default
 and 
\emph on
y
\emph default
? Note that this is a limitation of R.
 Note that R could be designed to avoid this problem (see our discussion
 of 
\emph on
pqR
\emph default
 earlier in this Unit).
\end_layout

\begin_layout Subsection
Passing objects to compiled code
\end_layout

\begin_layout Standard
As we've already discussed, when R objects are passed to compiled code (e.g.,
 C or C++), they are passed as pointers and the compiled code uses the memory
 allocated by R (though it could also allocate additional memory if allocation
 is part of the code).
 However, a copy of the object is made, so when calling a C function from
 R there is some memory overhead.
\end_layout

\begin_layout Standard
Furthermore, we need to be aware of any casting that occurs, because the
 compiled code requires that the R object types match those that the function
 in the compiled code is expecting.
 
\end_layout

\begin_layout Standard
Here's an example of calling compiled code:
\end_layout

\begin_layout Standard

\family typewriter
res <- .C("fastcount", PACKAGE="GCcorrect", tablex = as.integer(tablex),
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

tabley = as.integer(tabley), as.integer(xvar), as.integer(yvar),
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

as.integer(useline), as.integer(length(xvar)))
\end_layout

\begin_layout Standard
Let's consider when copies are made in casts:
\end_layout

\begin_layout Chunk
<<chunk35, eval=FALSE>>=
\end_layout

\begin_layout Chunk
f <- function(x){
\end_layout

\begin_layout Chunk
	print(.Internal(inspect(x)))
\end_layout

\begin_layout Chunk
	return(mean(x))
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
class(x)
\end_layout

\begin_layout Chunk
debug(f)
\end_layout

\begin_layout Chunk
f(x)
\end_layout

\begin_layout Chunk
f(as.numeric(x))
\end_layout

\begin_layout Chunk
f(as.integer(x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Next we'll see that C calls do involve a copy, even though it looks like
 we are just using the same object allocated by R.
 We'll use the 
\emph on
inline
\emph default
 package to work directly with C code in R and the .C functionality for interfaci
ng with C.
\end_layout

\begin_layout Chunk
<<chunk35a>>=
\end_layout

\begin_layout Chunk
library(inline) 
\end_layout

\begin_layout Chunk
src <- '
\end_layout

\begin_layout Chunk
	for (int i = 0; i < *n; i++) {
\end_layout

\begin_layout Chunk
		x[i] = exp(x[i]);
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
'
\end_layout

\begin_layout Chunk
sillyExp <- cfunction(signature(n = "integer", x = "numeric"),
\end_layout

\begin_layout Chunk
	src, convention = ".C")
\end_layout

\begin_layout Chunk
# sillyExp <- cfunction(signature(n = "integer", x = "numeric"),
\end_layout

\begin_layout Chunk
#    src, convention = ".C")
\end_layout

\begin_layout Chunk
len <- as.integer(100)  # or 100L
\end_layout

\begin_layout Chunk
vals <- rnorm(len)
\end_layout

\begin_layout Chunk
vals[1]
\end_layout

\begin_layout Chunk
out1 <- sillyExp(n = len, x = vals)
\end_layout

\begin_layout Chunk
.Internal(inspect(vals))
\end_layout

\begin_layout Chunk
.Internal(inspect(out1$x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Delayed copying (copy-on-change) 
\begin_inset CommandInset label
LatexCommand label
name "sub:Lazy-evaluation,-delayed"

\end_inset


\end_layout

\begin_layout Standard
Next we'll see that something like lazy evaluation occurs outside of functions
 as well with some functionality called 
\emph on
delayed copying
\emph default
 or 
\emph on
copy-on-change
\emph default
.
\end_layout

\begin_layout Standard
Let's see what goes on within a function in terms of memory use in different
 situations.
 Ignore the 
\emph on
gc()
\emph default
 results in the pdf, as we'll start R fresh to get a clean view of memory
 use during the class demo.
\end_layout

\begin_layout Chunk
<<chunk36, eval=TRUE>>=
\end_layout

\begin_layout Chunk
f <- function(x){
\end_layout

\begin_layout Chunk
	print(gc())
\end_layout

\begin_layout Chunk
	z <- x[1]
\end_layout

\begin_layout Chunk
	.Internal(inspect(x))
\end_layout

\begin_layout Chunk
	return(x)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
y <- rnorm(1e7)
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
out <- f(y)
\end_layout

\begin_layout Chunk
.Internal(inspect(out))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
In fact, this occurs outside function calls as well.
 Copies of objects are not made until one of the objects is actually modified.
 Initially, the copy points to the same memory location as the original
 object.
 
\end_layout

\begin_layout Chunk
<<chunk37, eval=TRUE>>=
\end_layout

\begin_layout Chunk
y <- rnorm(1e7)
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
x <- y
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
x[1] <- 5
\end_layout

\begin_layout Chunk
gc()
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
rm(x)
\end_layout

\begin_layout Chunk
x <- y
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
y[1] <- 5
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
As discussed by Radford Neal, who is working to improve the efficiency of
 R in a project called pqR, 
\emph on

\begin_inset Quotes eld
\end_inset

So R doesnt copy all the time.
 Instead, it maintains a count, called NAMED, of how many names refer
 to an object, and copies only when an object that needs to be modified
 is also referred to by another name.
 Unfortunately, however, this scheme works rather poorly.
 Many unnecessary copies are still made, while many bugs have arisen in
 which copies arent made when necessary.
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Here are examples of how the NAMED count can be fooled into making a copy
 unnecessarily.
 Why do I say these copies are unnecessary and why is NAMED fooled?
\begin_inset Note Note
status open

\begin_layout Plain Layout
X in frist case points to Y
\end_layout

\end_inset


\end_layout

\begin_layout Chunk
<<chunk37aaa>>=
\end_layout

\begin_layout Chunk
rm(x, y)
\end_layout

\begin_layout Chunk
f <- function(x) sum(x^2)
\end_layout

\begin_layout Chunk
y <- rnorm(10)
\end_layout

\begin_layout Chunk
f(y)
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
y[3] <- 2
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
a <- 1:5
\end_layout

\begin_layout Chunk
b <- a
\end_layout

\begin_layout Chunk
.Internal(inspect(a))
\end_layout

\begin_layout Chunk
.Internal(inspect(b))
\end_layout

\begin_layout Chunk
a[2] <- 0
\end_layout

\begin_layout Chunk
b[2] <- 4
\end_layout

\begin_layout Chunk
.Internal(inspect(a))
\end_layout

\begin_layout Chunk
.Internal(inspect(b))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Standard
We can use the 
\emph on
tracemem()
\emph default
 function to assess what is going on without all those 
\emph on
inspect()
\emph default
 calls.
 Anything surprising in what you see?
\end_layout

\begin_layout Chunk
<<chunk37aa>>=
\end_layout

\begin_layout Chunk
a <- 1:10     
\end_layout

\begin_layout Chunk
tracemem(a)      
\end_layout

\begin_layout Chunk
## b and a share memory      
\end_layout

\begin_layout Chunk
b <- a      
\end_layout

\begin_layout Chunk
b[1] <- 1      
\end_layout

\begin_layout Chunk
untracemem(a)    
\end_layout

\begin_layout Chunk
.Internal(inspect(a))
\end_layout

\begin_layout Chunk
.Internal(inspect(b))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Given our understanding of copy-on-change, explain what happens here:
\end_layout

\begin_layout Chunk
<<chunk37a, eval=TRUE>>=
\end_layout

\begin_layout Chunk
y <- 1:5
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
x <- y
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
y[2] <- 4
\end_layout

\begin_layout Chunk
.Internal(inspect(y))
\end_layout

\begin_layout Chunk
.Internal(inspect(x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: How much memory is used in the following calculation?
\end_layout

\begin_layout Chunk
<<chunk38>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1e7) 
\end_layout

\begin_layout Chunk
myfun <- function(y){ 
\end_layout

\begin_layout Chunk
	z <- y 
\end_layout

\begin_layout Chunk
	return(mean(z)) 
\end_layout

\begin_layout Chunk
} 
\end_layout

\begin_layout Chunk
myfun(x)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
How about here? What is going on?
\end_layout

\begin_layout Chunk
<<chunk39>>=
\end_layout

\begin_layout Chunk
x <- rnorm(1e7)
\end_layout

\begin_layout Chunk
x[1] <- NA
\end_layout

\begin_layout Chunk
myfun <- function(y){ 
\end_layout

\begin_layout Chunk
	return(mean(y, na.rm = TRUE))
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
myfun(x)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
This makes sense if we look at 
\emph on
mean.default()
\emph default
.
 Consider where additional memory is used.
 
\end_layout

\begin_layout Subsection
Strategies for saving memory
\end_layout

\begin_layout Standard
A couple basic strategies for saving memory include:
\end_layout

\begin_layout Itemize
Avoiding unnecessary copies
\end_layout

\begin_layout Itemize
Removing objects that are not being used and, if necessary, do a 
\emph on
gc()
\emph default
 call.
\end_layout

\begin_layout Standard
If you're really trying to optimize memory use, you may also consider:
\end_layout

\begin_layout Itemize
Using reference classes and similar strategies to pass by reference
\end_layout

\begin_layout Itemize
Substituting integer and logical vectors for numeric vectors when possible
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
Let's work through a real example where we keep a running tally of current
 memory in use and maximum memory used in a function call.
 We'll want to consider hidden uses of memory, passing objects to compiled
 code, and lazy evaluation.
 This code is courtesy of Yuval Benjamini.
 For our purposes here, let's assume that 
\emph on
xvar
\emph default
 and 
\emph on
yvar
\emph default
 are very long vectors using a lot of memory.
\end_layout

\begin_layout Chunk
<<chunk39a, eval = FALSE>>=
\end_layout

\begin_layout Chunk
fastcount <- function(xvar,yvar) {
\end_layout

\begin_layout Chunk
	naline <- is.na(xvar)
\end_layout

\begin_layout Chunk
	naline[is.na(yvar)] = TRUE
\end_layout

\begin_layout Chunk
	xvar[naline] <- 0
\end_layout

\begin_layout Chunk
	yvar[naline] <- 0
\end_layout

\begin_layout Chunk
	useline <- !naline;
\end_layout

\begin_layout Chunk
	# Table must be initialized for -1's
\end_layout

\begin_layout Chunk
	tablex <- numeric(max(xvar)+1)
\end_layout

\begin_layout Chunk
	tabley <- numeric(max(xvar)+1)
\end_layout

\begin_layout Chunk
	stopifnot(length(xvar) == length(yvar))
\end_layout

\begin_layout Chunk
	res <- .C("fastcount",PACKAGE="GCcorrect",
\end_layout

\begin_layout Chunk
		tablex = as.integer(tablex), tabley = as.integer(tabley),
\end_layout

\begin_layout Chunk
		as.integer(xvar), as.integer(yvar), as.integer(useline),
\end_layout

\begin_layout Chunk
		as.integer(length(xvar)))
\end_layout

\begin_layout Chunk
	xuse <- which(res$tablex>0)
\end_layout

\begin_layout Chunk
	xnames <- xuse - 1
\end_layout

\begin_layout Chunk
	resb <- rbind(res$tablex[xuse], res$tabley[xuse]) 
\end_layout

\begin_layout Chunk
	colnames(resb) <- xnames
\end_layout

\begin_layout Chunk
	return(resb)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Object-oriented programming (OOP) 
\end_layout

\begin_layout Standard
Popular languages that use OOP include C++, Java, and Python.
 In fact C++ is the object-oriented version of C.
 Different languages implement OOP in different ways.
\end_layout

\begin_layout Standard
The idea of OOP is that all operations are built around objects, which have
 a class, and methods that operate on objects in the class.
 Classes are constructed to build on (inherit from) each other, so that
 one class may be a specialized form of another class, extending the components
 and methods of the simpler class (e.g., 
\emph on
lm
\emph default
 and 
\emph on
glm
\emph default
 objects).
 
\end_layout

\begin_layout Standard
Note that in more formal OOP languages, all functions are associated with
 a class, while in R, only some are.
\end_layout

\begin_layout Standard
Often when you get to the point of developing OOP code in R, you're doing
 more serious programming, and you're going to be acting as a software engineer.
 It's a good idea to think carefully in advance about the design of the
 classes and methods.
 
\end_layout

\begin_layout Subsection
S3 approach
\end_layout

\begin_layout Standard
S3 classes are widely-used, in particular for statistical models in the
 
\emph on
stats
\emph default
 package.
 S3 classes are very informal in that there's not a formal definition for
 an S3 class.
 Instead, an S3 object is just a primitive R object such as a list or vector
 with additional attributes including a class name.
 
\end_layout

\begin_layout Paragraph
Inheritance
\end_layout

\begin_layout Standard
Let's look at the 
\emph on
lm
\emph default
 class, which builds on lists, and 
\emph on
glm
\emph default
 class, which builds on the 
\emph on
lm
\emph default
 class.
 Here 
\emph on
mod
\emph default
 is an object (an instance) of class 
\emph on
lm
\emph default
.
 An analogy is the difference between a random variable and a realization
 of that random variable.
\end_layout

\begin_layout Chunk
<<chunk39b>>=
\end_layout

\begin_layout Chunk
library(methods)
\end_layout

\begin_layout Chunk
yb <- sample(c(0, 1), 10, replace = TRUE)
\end_layout

\begin_layout Chunk
yc <- rnorm(10)
\end_layout

\begin_layout Chunk
x <- rnorm(10)
\end_layout

\begin_layout Chunk
mod1 <- lm(yc ~ x)
\end_layout

\begin_layout Chunk
mod2 <- glm(yb ~ x, family = binomial)
\end_layout

\begin_layout Chunk
class(mod1)
\end_layout

\begin_layout Chunk
class(mod2)
\end_layout

\begin_layout Chunk
is.list(mod1)
\end_layout

\begin_layout Chunk
names(mod1)
\end_layout

\begin_layout Chunk
is(mod2, "lm")
\end_layout

\begin_layout Chunk
methods(class = "lm")
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Often S3 classes inherit from lists (i.e., are special cases of lists), so
 you can obtain components of the object using the $ operator.
\end_layout

\begin_layout Paragraph
Creating our own class
\end_layout

\begin_layout Standard
We can create an object with a new class as follows:
\end_layout

\begin_layout Chunk
<<chunk40>>=
\end_layout

\begin_layout Chunk
me <- list(firstname = 'Chris', surname = 'Paciorek', age = NA)
\end_layout

\begin_layout Chunk
class(me) <- 'indiv' # there is already a 'person' class in R
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Actually, if we want to create a new class that we'll use again, we want
 to create a 
\emph on
constructor
\emph default
 function that initializes new individuals:
\end_layout

\begin_layout Chunk
<<chunk41>>=
\end_layout

\begin_layout Chunk
indiv <- function(firstname = NA, surname = NA, age = NA){
\end_layout

\begin_layout Chunk
	# constructor for 'indiv' class
\end_layout

\begin_layout Chunk
	obj <- list(firstname = firstname, surname = surname, age = age)
\end_layout

\begin_layout Chunk
	class(obj) <- 'indiv' 
\end_layout

\begin_layout Chunk
	return(obj)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
me <- indiv('Chris','Paciorek')
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
For those of you used to more formal OOP, the following is probably disconcertin
g:
\end_layout

\begin_layout Chunk
<<chunk41a>>=
\end_layout

\begin_layout Chunk
class(me) <- "silly"
\end_layout

\begin_layout Chunk
class(me) <- "indiv"
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Standard
The real power of OOP comes from defining 
\emph on
methods
\emph default
.
 For example,
\end_layout

\begin_layout Chunk
<<chunk42, eval=FALSE>>=
\end_layout

\begin_layout Chunk
mod <- lm(yc ~ x)
\end_layout

\begin_layout Chunk
summary(mod)
\end_layout

\begin_layout Chunk
gmod <- glm(yb ~ x, family = 'binomial')
\end_layout

\begin_layout Chunk
summary(gmod)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Here 
\emph on
summary()
\emph default
 is a generic method (or generic function) that, based on the type of object
 given to it (the first argument), dispatches a class-specific function
 (method) that operates on the object.
 This is convenient for working with objects using familiar functions.
 Consider the generic methods 
\emph on
plot()
\emph default
, 
\emph on
print()
\emph default
, 
\emph on
summary()
\emph default
, 
\emph on
`[`
\emph default
, and others.
 We can look at a function and easily see that it is a generic method.
 We can also see what classes have methods for a given generic method.
\end_layout

\begin_layout Chunk
<<chunk43>>=
\end_layout

\begin_layout Chunk
mean
\end_layout

\begin_layout Chunk
methods(mean)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
In many cases there will be a default method (here, 
\emph on
mean.default()
\emph default
), so if no method is defined for the class, R uses the default.
 Sidenote: arguments to a generic method are passed along to the selected
 method by passing along the calling environment.
 
\end_layout

\begin_layout Standard
We can define new generic methods:
\end_layout

\begin_layout Chunk
<<chunk44>>=
\end_layout

\begin_layout Chunk
summarize <- function(object, ...) 
\end_layout

\begin_layout Chunk
	UseMethod("summarize") 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Once 
\emph on
UseMethod()
\emph default
 is called, R searches for the specific method associated with the class
 of 
\emph on
object
\emph default
 and calls that method, without ever returning to the generic method.
 Let's try this out on our 
\emph on
indiv
\emph default
 class.
 In reality, we'd write either 
\emph on
summary.indiv()
\emph default
 or 
\emph on
print.indiv()
\emph default
 (and of course the generics for 
\emph on
summary
\emph default
 and 
\emph on
print
\emph default
 already exist) but for illustration, I wanted to show how we would write
 both the generic and the specific method, so I'll write a 
\emph on
summarize
\emph default
 method.
\end_layout

\begin_layout Chunk
<<chunk45>>=
\end_layout

\begin_layout Chunk
summarize.indiv <- function(object) 
\end_layout

\begin_layout Chunk
	return(with(object, cat("Individual of age ", age, 
\end_layout

\begin_layout Chunk
	" whose name is ", firstname, " ", surname, ".
\backslash
n",sep = "")))
\end_layout

\begin_layout Chunk
summarize(me)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Note that the 
\emph on
print()
\emph default
 function is what is called when you simply type the name of the object,
 so we can have object information printed out in a structured way.
 Recall that the output when we type the name of an 
\emph on
lm
\emph default
 object is NOT simply a regurgitation of the elements of the list - rather
 
\emph on
print.lm()
\emph default
 is called.
\end_layout

\begin_layout Standard
Similarly, when we used 
\family typewriter
print(object.size(x))
\family default
 we were invoking the 
\emph on
object_size
\emph default
-specific print method which gets the value of the size and then formats
 it.
 So there's actually a fair amount going on behind the scenes.
\end_layout

\begin_layout Standard
Surprisingly, the 
\emph on
summary()
\emph default
 method generally doesn't actually print out information; rather it computes
 things not stored in the original object and returns it as a new class
 (e.g., class 
\emph on
summary.lm
\emph default
), which is then automatically printed, per my comment above, using 
\emph on
print.summary.lm()
\emph default
, unless one assigns it to a new object.
 Note that 
\emph on
print.summary.lm()
\emph default
 is hidden from user view.
\end_layout

\begin_layout Chunk
<<chunk46, eval=FALSE>>=
\end_layout

\begin_layout Chunk
out <- summary(mod)
\end_layout

\begin_layout Chunk
out
\end_layout

\begin_layout Chunk
print(out)
\end_layout

\begin_layout Chunk
getS3method(f="print",class="summary.lm")
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Paragraph
More on inheritance
\end_layout

\begin_layout Standard
As noted with 
\emph on
lm
\emph default
 and 
\emph on
glm
\emph default
 objects, we can assign more than one class to an object.
 Here 
\emph on
summarize()
\emph default
 still works, even though the primary class is 
\emph on
BerkeleyIndiv
\emph default
.
\end_layout

\begin_layout Chunk
<<chunk47>>=
\end_layout

\begin_layout Chunk
class(me) <- c('BerkeleyIndiv', 'indiv')
\end_layout

\begin_layout Chunk
summarize(me) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The classes should nest within one another with the more specific classes
 to the left, e.g., here a 
\emph on
BerkeleyIndiv
\emph default
 would have some additional objects on top of those of an individual, perhaps
 
\emph on
CalnetID
\emph default
, and perhaps additional or modified methods.
 
\emph on
BerkeleyIndiv
\emph default
 inherits from 
\emph on
indiv
\emph default
, and R uses methods for the first class before methods for the next class(es),
 unless no such method is defined for the first class.
 If no methods are defined for any of the classes, R looks for 
\emph on
method.default()
\emph default
, e.g., 
\emph on
print.default()
\emph default
, 
\emph on
plot.default()
\emph default
, etc..
\end_layout

\begin_layout Paragraph
Class-specific operators
\end_layout

\begin_layout Standard
We can also use operators with our classes.
 The following example will be a bit silly (it would make more sense with
 a class that is a mathematical object) but indicates the power of having
 methods.
\end_layout

\begin_layout Chunk
<<chunk48>>=
\end_layout

\begin_layout Chunk
methods(`+`)
\end_layout

\begin_layout Chunk
`+.indiv` <- function(object, incr) {
\end_layout

\begin_layout Chunk
	object$age <- object$age + incr
\end_layout

\begin_layout Chunk
	return(object)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
old.me <- me + 15
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Paragraph
Class-specific replacement functions
\end_layout

\begin_layout Standard
We can use replacement functions with our classes.
 
\end_layout

\begin_layout Standard
This is again a bit silly but we could do the following.
 We need to define the generic replacement function and then the class-specific
 one.
\end_layout

\begin_layout Chunk
<<chunk49>>=
\end_layout

\begin_layout Chunk
`age<-` <- function(x, ...) UseMethod("age<-")
\end_layout

\begin_layout Chunk
`age<-.indiv` <- function(object, value){ 
\end_layout

\begin_layout Chunk
	object$age <- value
\end_layout

\begin_layout Chunk
	return(object)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
age(old.me) <- 60
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Paragraph
Why use class-specific methods?
\end_layout

\begin_layout Standard
We could have implemented different functionality (e.g., for 
\emph on
summary()
\emph default
) for different objects using a bunch of 
\emph on
if
\emph default
 statements (or 
\emph on
switch()
\emph default
) to figure out what class of object is the input, but then we need to have
 all that checking.
 Furthermore, we don't control the 
\emph on
summary()
\emph default
 function, so we would have no way of adding the additional conditions in
 a big if-else statement.
 The OOP framework makes things 
\emph on
extensible
\emph default
, so we can build our own new functionality on what is already in R.
\end_layout

\begin_layout Paragraph
Final thoughts
\end_layout

\begin_layout Standard
Consider the 
\emph on
Date
\emph default
 class discussed in the R bootcamp.
 This is another example of an S3 class, with methods such as 
\emph on
julian()
\emph default
, 
\emph on
weekdays()
\emph default
, etc.
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: how would you get R to quit immediately, without asking for any more informati
on, when you simply type '
\emph on
q
\emph default
' (no parentheses!)? 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hint: if you type 'q', what function is R going to use?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What we've just discussed are the old-style R (and S) object orientation,
 called S3 methods.
 The new style is called S4 and we'll discuss it next.
 S3 is still commonly used, in part because S4 can be slow (or at least
 it was when I last looked into this a few years ago).
 S4 is more structured than S3.
 
\end_layout

\begin_layout Subsection
S4 approach
\end_layout

\begin_layout Standard
S4 methods are used a lot in 
\emph on
bioconductor
\emph default
.
 They're also used in 
\emph on
lme4
\emph default
, among other packages.
 Tools for working with S4 classes are in the 
\emph on
methods
\emph default
 package.
\end_layout

\begin_layout Standard
Note that components of S4 objects are obtained as 
\family typewriter
object@component
\family default
 so they do not use the usual list syntax.
 The components are called 
\emph on
slots
\emph default
, and there is careful checking that the slots are specified and valid when
 a new object of a class is created.
 You can use the 
\emph on
prototype
\emph default
 argument to 
\emph on
setClass()
\emph default
 to set default values for the slots.
 There is a default constructor (the method is actually called 
\emph on
initialize()
\emph default
), but you can modify it.
 One can create methods for operators and for replacement functions too.
 For S4 classes, there is a default method invoked when 
\emph on
print()
\emph default
 is called on an object in the class (either explicitly or implicitly) -
 the method is actually called 
\emph on
show()
\emph default
 and it can also be modified.
 Let's reconsider our 
\emph on
indiv
\emph default
 class example in the S4 context.
\end_layout

\begin_layout Chunk
<<chunk50>>=
\end_layout

\begin_layout Chunk
library(methods)
\end_layout

\begin_layout Chunk
setClass("indiv",
\end_layout

\begin_layout Chunk
	representation(
\end_layout

\begin_layout Chunk
		name = "character",
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
		age = "numeric",
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
		birthday = "Date" 
\end_layout

\begin_layout Chunk
	)
\end_layout

\begin_layout Chunk
)
\end_layout

\begin_layout Chunk
me <- new("indiv", name = 'Chris', age = 20, 
\end_layout

\begin_layout Chunk
			birthday = as.Date('91-08-03'))
\end_layout

\begin_layout Chunk
# next notice the missing age slot
\end_layout

\begin_layout Chunk
me <- new("indiv", name = 'Chris', 
\end_layout

\begin_layout Chunk
	birthday = as.Date('91-08-03')) 
\end_layout

\begin_layout Chunk
# finally, apparently there's not a default object of class Date
\end_layout

\begin_layout Chunk
me <- new("indiv", name = 'Chris', age = 20)
\end_layout

\begin_layout Chunk
me
\end_layout

\begin_layout Chunk
me@age <- 60
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
S4 methods are designed to be more structured than S3, with careful checking
 of the slots.
\end_layout

\begin_layout Chunk
<<chunk51>>=
\end_layout

\begin_layout Chunk
setValidity("indiv",
\end_layout

\begin_layout Chunk
	function(object) {
\end_layout

\begin_layout Chunk
		if(!(object@age > 0 && object@age < 130)) 
\end_layout

\begin_layout Chunk
			return("error: age must be between 0 and 130")
\end_layout

\begin_layout Chunk
		if(length(grep("[0-9]", object@name))) 
\end_layout

\begin_layout Chunk
			return("error: name contains digits")
\end_layout

\begin_layout Chunk
		return(TRUE)
\end_layout

\begin_layout Chunk
	# what other validity check would make sense given the slots?
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
)
\end_layout

\begin_layout Chunk
me <- new("indiv", name = "5z%a", age = 20, 
\end_layout

\begin_layout Chunk
	birthday = as.Date('91-08-03'))
\end_layout

\begin_layout Chunk
me <- new("indiv", name = "Z%a B''*", age = 20, 
\end_layout

\begin_layout Chunk
	birthday = as.Date('91-08-03'))
\end_layout

\begin_layout Chunk
me@age <- 150 # so our validity check is not foolproof
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
To deal with this latter issue of the user mucking with the slots, it's
 recommended when using OOP that slots only be accessible through methods
 that operate on the object, e.g., a 
\emph on
setAge()
\emph default
 method, and then check the validity of the supplied age within 
\emph on
setAge()
\emph default
.
\end_layout

\begin_layout Standard
Here's how we create generic and class-specific methods.
 Note that in some cases the generic will already exist.
\end_layout

\begin_layout Chunk
<<chunk52>>=
\end_layout

\begin_layout Chunk
# generic method
\end_layout

\begin_layout Chunk
setGeneric("isVoter", function(object, ...) { standardGeneric("isVoter") })
\end_layout

\begin_layout Chunk
# class-specific method
\end_layout

\begin_layout Chunk
isVoter.indiv <- function(object){
\end_layout

\begin_layout Chunk
	if(object@age > 17){
\end_layout

\begin_layout Chunk
		cat(object@name, "is of voting age.
\backslash
n")
\end_layout

\begin_layout Chunk
	} else cat(object@name, "is not of voting age.
\backslash
n")
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
setMethod(isVoter, signature = c("indiv"), definition = isVoter.indiv)
\end_layout

\begin_layout Chunk
isVoter(me)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can have method signatures involve multiple objects.
 Here's some syntax where we'd fill in the function body with appropriate
 code - perhaps the plus operator would create a child.
\end_layout

\begin_layout Standard

\family typewriter
setMethod(`+`, signature = c("indiv", "indiv"), 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

definition = function(indiv1, indiv2) { }
\end_layout

\begin_layout Standard
As with S3, classes can inherit from one or more other classes.
 Chambers calls the class that is being inherited from a 
\emph on
superclass
\emph default
.
 
\end_layout

\begin_layout Chunk
<<chunk53>>=
\end_layout

\begin_layout Chunk
setClass("BerkeleyIndiv",
\end_layout

\begin_layout Chunk
	representation(
\end_layout

\begin_layout Chunk
		CalID = "character"
\end_layout

\begin_layout Chunk
	),
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
	contains = "indiv"
\end_layout

\begin_layout Chunk
)
\end_layout

\begin_layout Chunk
me <- new("BerkeleyIndiv", name = "Chris", age = 20, 
\end_layout

\begin_layout Chunk
   birthday = as.Date('91-08-03'), CalID = "01349542")
\end_layout

\begin_layout Chunk
isVoter(me)
\end_layout

\begin_layout Chunk
is(me, "indiv")
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
For a more relevant example suppose we had spatially-indexed time series.
 We could have a time series class, a spatial location class, and a 
\begin_inset Quotes eld
\end_inset

location time series
\begin_inset Quotes erd
\end_inset

 class that inherits from both.
 Be careful that there are not conflicts in the slots or methods from the
 multiple classes.
 For conflicting methods, you can define a method specific to the new class
 to deal with this.
 Also, if you define your own 
\emph on
initialize()
\emph default
 method, you'll need to be careful that you account for any initialization
 of the superclass(es) and for any classes that might inherit from your
 class (see help on 
\emph on
new()
\emph default
 and Chambers, p.
 360).
\end_layout

\begin_layout Standard
You can inherit from other S4 classes (which need to be defined or imported
 into the environment in which your class is created), but not S3 classes.
 You can inherit (at most one) of the basic R types, but not environments,
 symbols, or other non-standard types.
 You can use S3 classes in slots, but this requires that the S3 class be
 declared as an S4 class.
 To do this, you create S4 versions of S3 classes use 
\emph on
setOldClass()
\emph default
 - this creates a virtual class.
 This has been done, for example, for the 
\emph on
data.frame
\emph default
 class:
\end_layout

\begin_layout Chunk
<<chunk54>>=
\end_layout

\begin_layout Chunk
showClass("data.frame")
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can use 
\emph on
setClassUnion()
\emph default
 to create what Adler calls 
\emph on
superclass 
\emph default
and what Chambers calls a 
\emph on
virtual class
\emph default
 that allows for methods that apply to multiple classes.
 So if you have a person class and a pet class, you could create a 
\begin_inset Quotes eld
\end_inset

named lifeform
\begin_inset Quotes erd
\end_inset

 virtual class that has methods for working with name and age slots, since
 both people and pets would have those slots.
 You can't directly create an object in the virtual class.
\end_layout

\begin_layout Subsection
Reference classes
\end_layout

\begin_layout Standard
Reference classes are a new construct in R.
 They are classes somewhat similar to S4 that allow us to access their fields
 by reference.
 Importantly, they behave like pointers (the fields in the objects are 'mutable'
).
 Let's work through an example where we set up the fields of the class (like
 S4 slots) and class methods, including a constructor.
 Note that one cannot add fields to an already existing class.
\end_layout

\begin_layout Standard
Here's the initial definition of the class.
\end_layout

\begin_layout Chunk
<<chunk55>>=
\end_layout

\begin_layout Chunk
tsSimClass <- setRefClass("tsSimClass", 
\end_layout

\begin_layout Chunk
	fields = list(
\end_layout

\begin_layout Chunk
		   n = "numeric", 
\end_layout

\begin_layout Chunk
		   times = "numeric",
\end_layout

\begin_layout Chunk
		   corMat = "matrix",
\end_layout

\begin_layout Chunk
		   lagMat = "matrix",
\end_layout

\begin_layout Chunk
		   corParam = "numeric",
\end_layout

\begin_layout Chunk
		   U = "matrix",
\end_layout

\begin_layout Chunk
		   currentU = "logical"),
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
	methods = list(
\end_layout

\begin_layout Chunk
		initialize = function(times = 1:10, corParam = 1, ...){
\end_layout

\begin_layout Chunk
			   # we seem to need default values for the copy() method to function
 properly
\end_layout

\begin_layout Chunk
			   require(fields)
\end_layout

\begin_layout Chunk
			   times <<- times # field assignment requires using <<-
\end_layout

\begin_layout Chunk
			   n <<- length(times)
\end_layout

\begin_layout Chunk
			   corParam <<- corParam
\end_layout

\begin_layout Chunk
			   currentU <<- FALSE
\end_layout

\begin_layout Chunk
			   calcMats()
\end_layout

\begin_layout Chunk
			   callSuper(...) # calls initializer of base class (envRefClass)
\end_layout

\begin_layout Chunk
		},
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
		calcMats = function(){
\end_layout

\begin_layout Chunk
			   # Python-style doc string
\end_layout

\begin_layout Chunk
			   ' calculates correlation matrix and Cholesky factor ' 
\end_layout

\begin_layout Chunk
			   lagMat <- rdist(times) # local variable
\end_layout

\begin_layout Chunk
			   corMat <<- exp(-lagMat / corParam) # field assignment
\end_layout

\begin_layout Chunk
			   U <<- chol(corMat) # field assignment
\end_layout

\begin_layout Chunk
			   cat("Done updating correlation matrix and Cholesky factor
\backslash
n")
\end_layout

\begin_layout Chunk
			   currentU <<- TRUE
\end_layout

\begin_layout Chunk
		},
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
		changeTimes = function(newTimes){
\end_layout

\begin_layout Chunk
		   times <<- newTimes
\end_layout

\begin_layout Chunk
		   calcMats()
\end_layout

\begin_layout Chunk
		},
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
		show = function(){ # 'print' method
\end_layout

\begin_layout Chunk
		   cat("Object of class 'tsSimClass' with ", n, " time points.
\backslash
n", sep = '')
\end_layout

\begin_layout Chunk
		}
\end_layout

\begin_layout Chunk
	)
\end_layout

\begin_layout Chunk
)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can add methods after defining the class.
\end_layout

\begin_layout Chunk
<<chunk56>>=
\end_layout

\begin_layout Chunk
tsSimClass$methods(list(
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
	simulate = function(){
\end_layout

\begin_layout Chunk
		  ' simulates random processes from the model ' 
\end_layout

\begin_layout Chunk
		   if(!currentU)
\end_layout

\begin_layout Chunk
		  	 calcMats()
\end_layout

\begin_layout Chunk
		   return(crossprod(U, rnorm(n)))
\end_layout

\begin_layout Chunk
	})
\end_layout

\begin_layout Chunk
)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Now let's see how we would use the class.
\end_layout

\begin_layout Chunk
<<chunk57, fig.width=4, eval=FALSE>>=
\end_layout

\begin_layout Chunk
master <- tsSimClass$new(1:100, 10)
\end_layout

\begin_layout Chunk
master
\end_layout

\begin_layout Chunk
tsSimClass$help('calcMats')
\end_layout

\begin_layout Chunk
devs <- master$simulate()
\end_layout

\begin_layout Chunk
plot(master$times, devs, type = 'l')
\end_layout

\begin_layout Chunk
mycopy <- master
\end_layout

\begin_layout Chunk
myDeepCopy <- master$copy()
\end_layout

\begin_layout Chunk
master$changeTimes(seq(0,1, length = 100))
\end_layout

\begin_layout Chunk
mycopy$times[1:5]
\end_layout

\begin_layout Chunk
myDeepCopy$times[1:5]
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
A few additional points:
\end_layout

\begin_layout Itemize
As we just saw, a copy of an object is just a pointer to the original object,
 unless we explicitly invoke the 
\emph on
copy()
\emph default
 method.
\end_layout

\begin_layout Itemize
As with S3 and S4, classes can inherit from other classes.
 E.g., if we had a 
\emph on
simClass
\emph default
 and we wanted the 
\emph on
tsSimClass
\emph default
 to inherit from it:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
setRefClass("tsSimClass", contains = "simClass") 
\end_layout

\begin_layout Itemize
We can call a method inherited from the superclass from within a method
 of the same name with 
\emph on
callSuper(...)
\emph default
, as we saw for our 
\emph on
initialize()
\emph default
 method.
\end_layout

\end_deeper
\begin_layout Itemize
If we need to refer to a field or change a field we can do so without hard-codin
g the field name as:
\end_layout

\begin_layout Chunk
<<chunk58, eval=FALSE>>=
\end_layout

\begin_layout Chunk
master$field('times')[1:5]
\end_layout

\begin_layout Chunk
# the next line is dangerous in this case, since
\end_layout

\begin_layout Chunk
# currentU will no longer be accurate
\end_layout

\begin_layout Chunk
master$field('times', 1:10) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Itemize
Note that reference classes have Python style doc strings.
 We get help on a class with 
\emph on
class$help()
\emph default
, e.g.
 
\family typewriter
tsSimClass$help()
\family default
.
 This prints out information, including the doc strings.
\end_layout

\begin_layout Itemize
If you need to refer to the entire object within an object method, you refer
 to it as 
\emph on
.self
\emph default
.
 E.g., with our 
\emph on
tsSimClass
\emph default
 object, 
\family typewriter
.self$U
\family default
 would refer to the Cholesky factor.
 This is sometimes necessary to distinguish a class field from an argument
 to a method.
\end_layout

\begin_layout Section
Creating and working in an environment
\end_layout

\begin_layout Standard
We've already talked extensively about the environments that R creates.
 Occasionally you may want to create an environment in which to store objects.
 
\end_layout

\begin_layout Chunk
<<chunk59>>=
\end_layout

\begin_layout Chunk
e <- new.env()
\end_layout

\begin_layout Chunk
assign('x', 3, envir = e) # same as e$x <- 3
\end_layout

\begin_layout Chunk
e$x
\end_layout

\begin_layout Chunk
get('x', envir = e, inherits = FALSE) 
\end_layout

\begin_layout Chunk
# the FALSE avoids looking for x in the enclosing environments
\end_layout

\begin_layout Chunk
e$y <- 5
\end_layout

\begin_layout Chunk
objects(e)
\end_layout

\begin_layout Chunk
rm('x', envir = e)
\end_layout

\begin_layout Chunk
parent.env(e)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Before the existence of Reference Classes, using an environment was one
 way to pass objects by reference, avoiding having to re-assign the output.
 Here's an example where we iteratively update a random walk.
\end_layout

\begin_layout Chunk
<<chunk60>>=
\end_layout

\begin_layout Chunk
myWalk <- new.env(); myWalk$pos = 0
\end_layout

\begin_layout Chunk
nextStep <- function(walk) walk$pos <- walk$pos + sample(c(-1, 1), size
 = 1)
\end_layout

\begin_layout Chunk
nextStep(myWalk)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can use 
\emph on
eval()
\emph default
 to evaluate some code within a specified environment.
 By default, it evaluates in the result of 
\emph on
parent.frame()
\emph default
, which amounts to evaluating in the frame from which 
\emph on
eval()
\emph default
 was called.
 
\emph on
evalq()
\emph default
 avoids having to use 
\emph on
quote()
\emph default
.
\end_layout

\begin_layout Chunk
<<chunk61>>=
\end_layout

\begin_layout Chunk
eval(quote(pos <- pos + sample(c(-1, 1), 1)), envir = myWalk)
\end_layout

\begin_layout Chunk
evalq(pos <- pos + sample(c(-1, 1), 1), envir = myWalk) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Computing on the language
\end_layout

\begin_layout Subsection
The R interpreter
\end_layout

\begin_layout Paragraph
Parsing
\end_layout

\begin_layout Standard
When you run R, the R interpreter takes the code you type or the lines of
 code that are read in a batch session and parses each statement, translating
 the text into functional form.
 It substitutes objects for the symbols (names) that represent those objects
 and evaluates the statement, returning the resulting object.
 For complicated R code, this may be recursive.
\end_layout

\begin_layout Standard
Since everything in R is an object, the result of parsing is an object that
 we'll be able to investigate, and the result of evaluating the parsed statement
 is an object.
\end_layout

\begin_layout Standard
We'll see more on parsing in the next section.
\end_layout

\begin_layout Paragraph

\emph on
.Primitive()
\emph default
 and 
\emph on
.Internal()
\emph default
 (and 
\emph on
.External
\emph default
())
\end_layout

\begin_layout Standard
Some functionality is implemented internally within the C implementation
 that lies at the heart of R.
 If you see 
\emph on
.Internal()
\emph default
 or 
\emph on
.Primitive()
\emph default
 or 
\emph on
.External()
\emph default
, in the code of a function, you know it's implemented internally (and therefore
 generally very quickly).
 Unfortunately, it also means that you don't get to see R code that implements
 the functionality, though Chambers p.
 465 describes how you can look into the C source code.
 Basically you need to download the source code for the relevant package
 off of CRAN.
\end_layout

\begin_layout Chunk
<<chunk62>>=
\end_layout

\begin_layout Chunk
plot.xy # plot.xy() is called by plot.default()
\end_layout

\begin_layout Chunk
print(`%*%`)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Parsing code and understanding language objects
\end_layout

\begin_layout Standard
R code can be manipulated in text form and we can actually write R code
 that will create or manipulate R code.
 We can then evaluate that R code using 
\emph on
eval()
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
quote()
\emph default
 will parse R code, but not evaluate it.
 This allows you to work with the code rather than the results of evaluating
 that code.
 The 
\emph on
print()
\emph default
 method for language objects is not very helpful! But we can see the parsed
 code by treating the result as a list.
\end_layout

\begin_layout Chunk
<<chunk63, tidy=FALSE>>=
\end_layout

\begin_layout Chunk
obj <- quote(if (x > 1) "orange" else "apple")
\end_layout

\begin_layout Chunk
as.list(obj)
\end_layout

\begin_layout Chunk
class(obj)
\end_layout

\begin_layout Chunk
weirdObj <- quote(`if`(x > 1, 'orange', 'apple'))
\end_layout

\begin_layout Chunk
identical(obj, weirdObj)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Recall that to access symbols that involve special syntax (such as special
 characters), you use backquotes.
\end_layout

\begin_layout Standard
Officially, the name that you assign to an object (including functions)
 is a 
\emph on
symbol
\emph default
.
 
\end_layout

\begin_layout Chunk
<<chunk64>>=
\end_layout

\begin_layout Chunk
x <- 3; typeof(quote(x))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can create an 
\emph on
expression
\emph default
 object that contains R code as
\end_layout

\begin_layout Chunk
<<chunk65>>=
\end_layout

\begin_layout Chunk
myExpr <- expression(x <- 3)
\end_layout

\begin_layout Chunk
eval(myExpr)
\end_layout

\begin_layout Chunk
typeof(myExpr)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The difference between 
\emph on
quote()
\emph default
 and 
\emph on
expression()
\emph default
 is basically that 
\emph on
quote()
\emph default
 works with a single statement, while 
\emph on
expression()
\emph default
 can deal with multiple statements, returning a list-like object of parsed
 statements.
 Both of them parse R code.
\end_layout

\begin_layout Chunk
<<chunk65a>>=
\end_layout

\begin_layout Chunk
a <- quote(x <- 5)
\end_layout

\begin_layout Chunk
b <- expression(x <- 5, y <- 3)
\end_layout

\begin_layout Chunk
class(a)
\end_layout

\begin_layout Chunk
class(b)
\end_layout

\begin_layout Chunk
b[[1]]
\end_layout

\begin_layout Chunk
class(b[[1]])
\end_layout

\begin_layout Chunk
identical(a, b[[1]])
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The following table shows the 
\emph on
language
\emph default
 objects in R; note that there are three classes of language objects: 
\emph on
expressions
\emph default
, 
\emph on
calls
\emph default
, and 
\emph on
names
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example syntax to create
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
object names
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
symbol (language)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expressions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression(x <- 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression (language)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(f())
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if statements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(if(x < 3) y=5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
for statement
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(for(i in 1:5) {})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
for (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assignments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(x <- 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<- (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operators
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(3 + 7)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset

Basically any standard function, operator, 
\emph on
if
\emph default
 statement, 
\emph on
for
\emph default
 statement, assignment, etc.
 are function calls and inherit from the 
\emph on
call
\emph default
 class.
 
\end_layout

\begin_layout Standard
Objects of type language are not officially lists, but they can be queried
 as such.
 You can convert between language objects and lists with 
\emph on
as.list()
\emph default
 and 
\emph on
as.call()
\emph default
.
 
\end_layout

\begin_layout Standard
An official expression is one or more syntactically correct R statements.
 When we use 
\emph on
quote()
\emph default
, we're working with a single statement, while 
\emph on
expression()
\emph default
 will create a list of separate statements (essentially separate call objects).
 I'm trying to use the term 
\emph on
statement
\emph default
 to refer colloquially to R code, rather than using the term 
\emph on
expression
\emph default
, since that has formal definition in this context.
\end_layout

\begin_layout Standard
Let's take a look at some examples of language objects and parsing.
\end_layout

\begin_layout Chunk
<<chunk65aa, tidy=FALSE>>=
\end_layout

\begin_layout Chunk
e0 <- quote(3)
\end_layout

\begin_layout Chunk
e1 <- expression(x <- 3) 
\end_layout

\begin_layout Chunk
e1m <- expression({x <- 3; y <- 5}) 
\end_layout

\begin_layout Chunk
e2 <- quote(x <- 3) 
\end_layout

\begin_layout Chunk
e3 <- quote(rnorm(3))
\end_layout

\begin_layout Chunk
print(c(class(e0), typeof(e0)))
\end_layout

\begin_layout Chunk
print(c(class(e1), typeof(e1)))
\end_layout

\begin_layout Chunk
print(c(class(e1[[1]]), typeof(e1[[1]])))
\end_layout

\begin_layout Chunk
print(c(class(e1m), typeof(e1m)))
\end_layout

\begin_layout Chunk
print(c(class(e2), typeof(e2)))
\end_layout

\begin_layout Chunk
identical(e1[[1]], e2)
\end_layout

\begin_layout Chunk
print(c(class(e3), typeof(e3)))
\end_layout

\begin_layout Chunk
e4 <- quote(-7)
\end_layout

\begin_layout Chunk
print(c(class(e4), typeof(e4))) # huh? what does this imply?
\end_layout

\begin_layout Chunk
as.list(e4)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can evaluate language types using 
\emph on
eval()
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk66>>=
\end_layout

\begin_layout Chunk
rm(x)
\end_layout

\begin_layout Chunk
eval(e1)
\end_layout

\begin_layout Chunk
rm(x)
\end_layout

\begin_layout Chunk
eval(e2)
\end_layout

\begin_layout Chunk
e1mlist <- as.list(e1m)
\end_layout

\begin_layout Chunk
e2list <- as.list(e2)
\end_layout

\begin_layout Chunk
eval(as.call(e2list)) 
\end_layout

\begin_layout Chunk
# here's how to do it if the language object is actually an expression (multiple
 statements)
\end_layout

\begin_layout Chunk
eval(as.expression(e1mlist))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Now let's look in more detail at the components of R expressions.
 We'll be able to get a sense from this of how R evaluates code.
 We see that when R evaluates a parse tree, the first element says what
 function to use and the remaining elements are the arguments.
 But in many cases one or more arguments will themselves be call objects,
 so there's recursion.
\end_layout

\begin_layout Chunk
<<chunk67>>=
\end_layout

\begin_layout Chunk
e1 = expression(x <- 3) 
\end_layout

\begin_layout Chunk
# e1 is one-element list with the element an object of class '<-' 
\end_layout

\begin_layout Chunk
print(c(class(e1), typeof(e1)))
\end_layout

\begin_layout Chunk
e1[[1]]
\end_layout

\begin_layout Chunk
as.list(e1[[1]])
\end_layout

\begin_layout Chunk
lapply(e1[[1]], class)
\end_layout

\begin_layout Chunk
y = rnorm(5)
\end_layout

\begin_layout Chunk
e3 = quote(mean(y))
\end_layout

\begin_layout Chunk
print(c(class(e3), typeof(e3)))
\end_layout

\begin_layout Chunk
e3[[1]] 
\end_layout

\begin_layout Chunk
print(c(class(e3[[1]]), typeof(e3[[1]])))
\end_layout

\begin_layout Chunk
e3[[2]]
\end_layout

\begin_layout Chunk
print(c(class(e3[[2]]), typeof(e3[[2]])))
\end_layout

\begin_layout Chunk
# we have recursion
\end_layout

\begin_layout Chunk
e3 = quote(mean(c(12,13,15)))
\end_layout

\begin_layout Chunk
as.list(e3)
\end_layout

\begin_layout Chunk
as.list(e3[[2]])
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Subsection
Manipulating the parse tree
\end_layout

\begin_layout Standard
Of course since the parsed code is just an object, we can manipulate it,
 i.e., 
\emph on
compute on the language
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk68>>=
\end_layout

\begin_layout Chunk
out <- quote(y <- 3)
\end_layout

\begin_layout Chunk
out[[3]] <- 4
\end_layout

\begin_layout Chunk
eval(out)
\end_layout

\begin_layout Chunk
y
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Here's another example:
\end_layout

\begin_layout Chunk
<<chunk69>>=
\end_layout

\begin_layout Chunk
e1 <- quote(4 + 5)
\end_layout

\begin_layout Chunk
e2 <- quote(plot(x, y))
\end_layout

\begin_layout Chunk
e2[[1]] <- `+`
\end_layout

\begin_layout Chunk
eval(e2)
\end_layout

\begin_layout Chunk
e1[[3]] <- e2
\end_layout

\begin_layout Chunk
e1
\end_layout

\begin_layout Chunk
class(e1[[3]]) # note the nesting
\end_layout

\begin_layout Chunk
eval(e1) # what should I get?
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can also turn it back into standard R code, as a character, using 
\emph on
deparse()
\emph default
, which turns the parse tree back into R code as text.
 
\emph on
parse()
\emph default
 is like 
\emph on
quote()
\emph default
 but it takes the code in the form of a string rather than an actual expression:
\end_layout

\begin_layout Chunk
<<chunk70>>=
\end_layout

\begin_layout Chunk
codeText <- deparse(out)
\end_layout

\begin_layout Chunk
parsedCode <- parse(text = codeText) 
\end_layout

\begin_layout Chunk
# parse() works like quote() except on the code in the form of a string
\end_layout

\begin_layout Chunk
eval(parsedCode)
\end_layout

\begin_layout Chunk
deparse(quote(if (x > 1) "orange" else "apple"))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Note that the quotes have been escaped since they're inside a string.
\end_layout

\begin_layout Standard
It can be very useful to be able to convert names of objects that are in
 the form of text to names that R interprets as symbols referring to objects:
\end_layout

\begin_layout Chunk
<<chunk71>>=
\end_layout

\begin_layout Chunk
x3 <- 7
\end_layout

\begin_layout Chunk
i <- 3
\end_layout

\begin_layout Chunk
as.name(paste('x', i, sep=''))
\end_layout

\begin_layout Chunk
eval(as.name(paste('x', i, sep='')))
\end_layout

\begin_layout Chunk
assign(paste('x', i, sep = ''), 11)
\end_layout

\begin_layout Chunk
x3
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Subsection
Parsing replacement expressions
\end_layout

\begin_layout Standard
Let's consider replacement expressions.
 
\end_layout

\begin_layout Chunk
<<chunk73>>=
\end_layout

\begin_layout Chunk
animals = c('cat', 'dog', 'rat','mouse')
\end_layout

\begin_layout Chunk
out1 = quote(animals[4] <- 'rat') 
\end_layout

\begin_layout Chunk
out2 = quote(`<-`(animals[4], 'rat')) 
\end_layout

\begin_layout Chunk
out3 = quote('[<-'(animals,4,'rat')) 
\end_layout

\begin_layout Chunk
as.list(out1)
\end_layout

\begin_layout Chunk
as.list(out2)
\end_layout

\begin_layout Chunk
identical(out1, out2)
\end_layout

\begin_layout Chunk
as.list(out3)
\end_layout

\begin_layout Chunk
identical(out1, out3)
\end_layout

\begin_layout Chunk
typeof(out1[[2]]) # language
\end_layout

\begin_layout Chunk
class(out1[[2]]) # call
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The parse tree for 
\emph on
out3
\emph default
 is different than those for 
\emph on
out1
\emph default
 and 
\emph on
out2
\emph default
, but when 
\emph on
out3
\emph default
 is evaluated the result is the same as for 
\emph on
out1
\emph default
 and 
\emph on
out2
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk74>>=
\end_layout

\begin_layout Chunk
eval(out1)
\end_layout

\begin_layout Chunk
animals
\end_layout

\begin_layout Chunk
animals[4] = 'mouse'  # reset things to original state
\end_layout

\begin_layout Chunk
eval(out3) 
\end_layout

\begin_layout Chunk
animals # both do the same thing
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Why? When R evaluates a call to `<-`, if the first argument is a name, then
 it does the assignment, but if the first argument (i.e.
 what's on the left-hand side of the 
\begin_inset Quotes eld
\end_inset

assignment
\begin_inset Quotes erd
\end_inset

) is a call then it calls the appropriate replacement function.
 The second argument (the value being assigned) is evaluated first.
 Ultimately in all of these cases, the replacement function is used.
\end_layout

\begin_layout Subsection
substitute()
\end_layout

\begin_layout Standard
The substitute function acts like 
\emph on
quote()
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk75>>=
\end_layout

\begin_layout Chunk
identical(quote(z <- x^2), substitute(z <- x^2))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
But if you also pass 
\emph on
substitute()
\emph default
 an environment, it will replace symbols with their object values in that
 environment.
\end_layout

\begin_layout Chunk
<<chunk76>>=
\end_layout

\begin_layout Chunk
e <- new.env(); e$x <- 3
\end_layout

\begin_layout Chunk
substitute(z <- x^2, e)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
This can do non-sensical stuff:
\end_layout

\begin_layout Chunk
<<chunk77>>=
\end_layout

\begin_layout Chunk
e$z <- 5
\end_layout

\begin_layout Chunk
substitute(z <- x^2, e)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Let's see a practical example of substituting for variables in statements:
\end_layout

\begin_layout Standard

\family typewriter
plot(x = rnorm(5), y = rgamma(5, 1)) # how does plot get the axis label
 names?
\family default

\begin_inset Newline newline
\end_inset

In the 
\emph on
plot()
\emph default
 function, you can see this syntax:
\end_layout

\begin_layout Standard

\family typewriter
xlabel <- if(!missing(x)) deparse(substitute(x))
\family default

\begin_inset Newline newline
\end_inset

So what's going on is that within 
\emph on
plot.default()
\emph default
, it substitutes in for '
\emph on
x
\emph default
' with the statement that was passed in as the 
\emph on
x
\emph default
 argument, and then uses 
\emph on
deparse()
\emph default
 to convert to character.
 The fact that 
\emph on
x
\emph default
 still has 
\emph on
rnorm(5)
\emph default
 associated with it rather than the five numerical values from evaluating
 
\emph on
rnorm()
\emph default
 has to do with lazy evaluation and promises.
 Here's the same idea in action in a stripped down example:
\end_layout

\begin_layout Chunk
<<chunk72>>=
\end_layout

\begin_layout Chunk
f <- function(obj){
\end_layout

\begin_layout Chunk
objName <- deparse(substitute(obj))
\end_layout

\begin_layout Chunk
print(objName)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
f(y)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
More generally, we can substitute into 
\emph on
expression
\emph default
 and 
\emph on
call
\emph default
 objects by providing a named list (or an environment) - the substition
 happens within the context of this list.
\end_layout

\begin_layout Chunk
<<chunk78>>=
\end_layout

\begin_layout Chunk
substitute(a + b, list(a = 1, b = quote(x)))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Things can get intricate quickly:
\end_layout

\begin_layout Chunk
<<chunk79>>=
\end_layout

\begin_layout Chunk
e1 <- quote(x + y)
\end_layout

\begin_layout Chunk
e2 <- substitute(e1, list(x = 3))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
The problem is that 
\emph on
substitute()
\emph default
 doesn't evaluate its first argument, 
\begin_inset Quotes eld
\end_inset


\emph on
e1
\emph default

\begin_inset Quotes erd
\end_inset

, so it can't replace the parsed elements in 
\emph on
e1
\emph default
.
 Instead, we'd need to do the following, where we force the evaluation of
 
\emph on
e1
\emph default
:
\end_layout

\begin_layout Chunk
<<chunk80>>=
\end_layout

\begin_layout Chunk
e2 <- substitute(substitute(e, list(x = 3)), list(e = e1))
\end_layout

\begin_layout Chunk
substitute(substitute(e, list(x = 3)), list(e = e1)) 
\end_layout

\begin_layout Chunk
# so e1 is substituted as an evaluated object, 
\end_layout

\begin_layout Chunk
# which then allows for substitution for 'x' 
\end_layout

\begin_layout Chunk
e2
\end_layout

\begin_layout Chunk
eval(e2)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
If this subsection is confusing, let me assure you that it has confused
 me too.
 The indirection going on here is very involved.
\end_layout

\begin_layout Subsection
Final thoughts
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: figure out how a 
\emph on
for
\emph default
 loop is parsed in R.
 See how a 
\emph on
for
\emph default
 loop with one statement within the loop differs from one with two or more
 statements.
\end_layout

\begin_layout Standard
We'll see 
\emph on
expression()
\emph default
 again when we talk about inserting mathematical notation in plots.
\end_layout

\end_body
\end_document
